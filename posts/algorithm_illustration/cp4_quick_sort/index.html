<!doctype html>
<html lang="zh_CN">
  <head>
    <title>AL: 4. Quicksort // I&#39;m Li. Mingzhi</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.68.3" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Li. Mingzhi" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="AL: 4. Quicksort"/>
<meta name="twitter:description" content="This chapter I learned divide-and-conquer and quicksort, both of which can help me solve problems elegently.
 1. Divide &amp; Conquer  It can take us some time to understand D&amp;C. Therefore, we will see some problems to learn about it.
 Example If you are a farmer with a large land and plan to divide this farmland evenly into square plots.
Besides, the plots must be as big as possible."/>

    <meta property="og:title" content="AL: 4. Quicksort" />
<meta property="og:description" content="This chapter I learned divide-and-conquer and quicksort, both of which can help me solve problems elegently.
 1. Divide &amp; Conquer  It can take us some time to understand D&amp;C. Therefore, we will see some problems to learn about it.
 Example If you are a farmer with a large land and plan to divide this farmland evenly into square plots.
Besides, the plots must be as big as possible." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/algorithm_illustration/cp4_quick_sort/" />
<meta property="article:published_time" content="2020-12-09T08:32:27+08:00" />
<meta property="article:modified_time" content="2020-12-09T08:32:27+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href=""><img class="app-header-avatar" src="/avatar.jpg" alt="Li. Mingzhi" /></a>
      <h1>I&#39;m Li. Mingzhi</h1>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/posts/resume/">Resume</a>
            |
          
          <a class="app-header-menu-item" href="/">Home</a>
      </nav>
      <p>I am a Backend Software Engineer focusing on system design and algorithm. ^_^　　Progress one percent per day...</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/mingzhi198" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
          <a target="_blank" href="https://www.jianshu.com/u/f9f3adb6764a" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-link">
  <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
  <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
</svg></a>
        
          <a target="_blank" href="https://twitter.com/mingzhi198" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter">
  <title>twitter</title>
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">AL: 4. Quicksort</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Dec 9, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          7 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line>
</svg>
              <a class="tag" href="/tags/algorithm/">algorithm</a>
              <a class="tag" href="/tags/sort/">sort</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <blockquote>
<p>This chapter I learned divide-and-conquer and quicksort, both of which can help me solve problems elegently.</p>
</blockquote>
<h3 id="1-divide--conquer">1. Divide &amp; Conquer</h3>
<blockquote>
<p>It can take us some time to understand D&amp;C. Therefore, we will see some problems to learn about it.</p>
</blockquote>
<h4 id="example">Example</h4>
<p>If you are a farmer with a large land and plan to divide this farmland evenly into square plots.<br>
Besides, the plots must be as big as possible.
Before continuing your reading, think about how can you solve this problem?</p>
<p>We can use D&amp;C(Divde &amp; Conquer) to solve this problem.<br>
To solve a problem using D&amp;C, we should follow two steps:</p>
<pre><code>1. Figure out the base case, which should be the simplest possible case.
2. Divide or decrease you problem until it becomes the base case.
</code></pre><p>Suppose you have a land of 30 * 50, now you have the largest square with side of 30.<br>
We have the rest of the land(20 * 30) and have the largest square of 20 * 20.
Then we are left with a land of 10 * 10, which is the answer.</p>
<ul>
<li>Golang</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Golang" data-lang="Golang"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">findMaxEvenSquareR</span>(<span style="color:#a6e22e">width</span>, <span style="color:#a6e22e">height</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">height</span> <span style="color:#f92672">||</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">width</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">height</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">width</span>
	}

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">height</span> &gt; <span style="color:#a6e22e">width</span> {
		<span style="color:#a6e22e">height</span> = <span style="color:#a6e22e">height</span> <span style="color:#f92672">%</span> <span style="color:#a6e22e">width</span>
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#a6e22e">width</span> = <span style="color:#a6e22e">width</span> <span style="color:#f92672">%</span> <span style="color:#a6e22e">height</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">findMaxEvenSquareR</span>(<span style="color:#a6e22e">width</span>, <span style="color:#a6e22e">height</span>)
}
</code></pre></div><h3 id="2-exercises">2. Exercises:</h3>
<ol>
<li>Add up all numbers and return the total.</li>
</ol>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sumR</span>(arr):
    <span style="color:#66d9ef">if</span> len(arr) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
        <span style="color:#66d9ef">return</span> arr[<span style="color:#ae81ff">0</span>] 
    <span style="color:#66d9ef">return</span> arr[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> sumR(arr[<span style="color:#ae81ff">1</span>:])
</code></pre></div><ul>
<li>Golang</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Golang" data-lang="Golang"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sumR</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">total</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">arr</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">0</span>]
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> <span style="color:#a6e22e">sumR</span>(<span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">1</span>:])
}
</code></pre></div><ol start="2">
<li>Write a recursive function to count the number of elements in a list</li>
</ol>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">countEleR</span>(arr): 
    <span style="color:#66d9ef">if</span> len(arr) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> 
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> countEleR(arr[<span style="color:#ae81ff">1</span>:])
</code></pre></div><ol start="3">
<li>Find the maximum number in a list</li>
</ol>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findMaxR</span>(arr): 
    <span style="color:#66d9ef">if</span> len(arr) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
        <span style="color:#66d9ef">return</span> arr[<span style="color:#ae81ff">0</span>]
    ret <span style="color:#f92672">=</span> findMaxR(arr[<span style="color:#ae81ff">1</span>:])
    <span style="color:#66d9ef">if</span> arr[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&gt;</span> ret:
        <span style="color:#66d9ef">return</span> arr[<span style="color:#ae81ff">0</span>] 
    <span style="color:#66d9ef">else</span>:
        <span style="color:#66d9ef">return</span> ret 
</code></pre></div><ol start="4">
<li>Write the D&amp;C code for Binary Search</li>
</ol>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">binarySearchR</span>(list, item, low, high):
    <span style="color:#66d9ef">if</span> low <span style="color:#f92672">&gt;</span> high:
        <span style="color:#66d9ef">return</span> None 

    mid <span style="color:#f92672">=</span> (low <span style="color:#f92672">+</span> high) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>
    guess <span style="color:#f92672">=</span> list[mid]
    <span style="color:#66d9ef">if</span> guess <span style="color:#f92672">&gt;</span> item: 
        high <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> 
    <span style="color:#66d9ef">else</span>: 
        low <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">return</span> binarySearchR(list, item, low, high)
</code></pre></div><ul>
<li>Golang</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Golang" data-lang="Golang"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">binarySearchR</span>(<span style="color:#a6e22e">list</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">item</span>, <span style="color:#a6e22e">low</span>, <span style="color:#a6e22e">high</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#75715e">// 1. figure out the base case
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">low</span> &gt; <span style="color:#a6e22e">high</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
	}

	<span style="color:#75715e">//. 2. reduce the problem and get to the base case
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mid</span> <span style="color:#f92672">:=</span> (<span style="color:#a6e22e">low</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">high</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>
	<span style="color:#a6e22e">guess</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">list</span>[<span style="color:#a6e22e">mid</span>]
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">guess</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">item</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">mid</span>
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">guess</span> &gt; <span style="color:#a6e22e">item</span> {
		<span style="color:#a6e22e">high</span> = <span style="color:#a6e22e">mid</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#a6e22e">low</span> = <span style="color:#a6e22e">mid</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">binarySearchR</span>(<span style="color:#a6e22e">list</span>, <span style="color:#a6e22e">item</span>, <span style="color:#a6e22e">low</span>, <span style="color:#a6e22e">high</span>)
}
</code></pre></div><blockquote>
<p>Tip: When we got a recursive function involving an array, the base case is often an empty array or an array with one element.</p>
</blockquote>
<h2 id="3-quick-sort">3. Quick Sort</h2>
<p>3.1 Quicksort is a sorting algorithm, which is much faster than selection sort and commonly used in life.
The base case for quicksort are arrays that are empty and arrays with just one element.
Using D&amp;C, we can break down a array until we get the base case.</p>
<ul>
<li>Here are the steps for quick sort:</li>
</ul>
<blockquote>
<ol>
<li>Pick an element from the array as the pivot</li>
<li>Find the elements smaller than the privot and the elements larger than it(This is called Partitioning).</li>
<li>Call quicksort recursively on the two sub-arrays.</li>
<li>The sub-arrays get sorted, and then we combine the whole thing to get a sorted array.</li>
</ol>
</blockquote>
<p>3.2  Here we can see one example from the book.</p>
<p>After partitioning, we get three parts: numbers less than the pivot, the pivot and numbers greater than the pivot.</p>
<p><img src="/posts/algorithm_illustration/images/quick_sort_1.png" alt="alt quick_sort_1"></p>
<p>Next, we&rsquo;ll quick sort the two sub-arrays.</p>
<p><img src="/posts/algorithm_illustration/images/quick_sort_2.png" alt="alt quick_sort_2"></p>
<p>Even though the two sub-arrays are not sorted, they&rsquo;re partitioned.
However, sorting the whole array would be pretty easy, if they were sorted.</p>
<p>Then, we can combine the whole thing together, like this: left array + pivot + right array.
We do this recursively and will get a sorted array.<br>
Here is the code, which would be easy to understand(In order to save space, We provide only the Golang code).</p>
<ul>
<li>Golang</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Golang" data-lang="Golang"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">quickSort</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">ret</span> []<span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">arr</span>) &lt; <span style="color:#ae81ff">2</span> {
		<span style="color:#a6e22e">ret</span> = append(<span style="color:#a6e22e">ret</span>, <span style="color:#a6e22e">arr</span><span style="color:#f92672">...</span>)
		<span style="color:#66d9ef">return</span>
	}

	<span style="color:#a6e22e">pivot</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">0</span>]
	<span style="color:#a6e22e">less</span>, <span style="color:#a6e22e">greater</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{}, []<span style="color:#66d9ef">int</span>{}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">1</span>:] {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">pivot</span> {
			<span style="color:#a6e22e">less</span> = append(<span style="color:#a6e22e">less</span>, <span style="color:#a6e22e">v</span>)
		} <span style="color:#66d9ef">else</span> {
			<span style="color:#a6e22e">greater</span> = append(<span style="color:#a6e22e">greater</span>, <span style="color:#a6e22e">v</span>)
		}
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;less: &#34;</span>, <span style="color:#a6e22e">less</span>, <span style="color:#e6db74">&#34;, pivot: &#34;</span>, <span style="color:#a6e22e">pivot</span>, <span style="color:#e6db74">&#34;, greater: &#34;</span>, <span style="color:#a6e22e">greater</span>)
	<span style="color:#a6e22e">lessRet</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">quickSort</span>(<span style="color:#a6e22e">less</span>)
	<span style="color:#a6e22e">greaterRet</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">quickSort</span>(<span style="color:#a6e22e">greater</span>)

	<span style="color:#a6e22e">ret</span> = append(<span style="color:#a6e22e">ret</span>, <span style="color:#a6e22e">lessRet</span><span style="color:#f92672">...</span>)
	<span style="color:#a6e22e">ret</span> = append(<span style="color:#a6e22e">ret</span>, <span style="color:#a6e22e">pivot</span>)
	<span style="color:#a6e22e">ret</span> = append(<span style="color:#a6e22e">ret</span>, <span style="color:#a6e22e">greaterRet</span><span style="color:#f92672">...</span>)
	<span style="color:#66d9ef">return</span>
}
</code></pre></div><p>If you&rsquo;d come through the explanation above, you would find this code easy to understand.
Nevertheless, it&rsquo;s not efficent in memory.
Here you can see codes optimized by using no extra memory space.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Golang" data-lang="Golang"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">quickSortE</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">arr</span>) &lt; <span style="color:#ae81ff">2</span> {
		<span style="color:#66d9ef">return</span>
	}

	<span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">arr</span>)
	<span style="color:#a6e22e">pivot</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">l</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
	<span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span> <span style="color:#75715e">// idx of element bigger than pivot
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">l</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>] &gt; <span style="color:#a6e22e">pivot</span> {
			<span style="color:#66d9ef">continue</span>
		}
		<span style="color:#a6e22e">swap</span>(<span style="color:#a6e22e">arr</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span>)
		<span style="color:#a6e22e">j</span><span style="color:#f92672">++</span>
	}
	<span style="color:#a6e22e">swap</span>(<span style="color:#a6e22e">arr</span>, <span style="color:#a6e22e">j</span>, <span style="color:#a6e22e">l</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
	<span style="color:#a6e22e">quickSortE</span>(<span style="color:#a6e22e">arr</span>[:<span style="color:#a6e22e">j</span>])
	<span style="color:#a6e22e">quickSortE</span>(<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:])
	<span style="color:#66d9ef">return</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">swap</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span>] = <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span>], <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>]
}
</code></pre></div><p>In order to have better performance, we use random element as the pivot:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Golang" data-lang="Golang"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">quickSortERand</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">arr</span>) &lt; <span style="color:#ae81ff">2</span> {
		<span style="color:#66d9ef">return</span>
	}

	<span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">arr</span>)
	<span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Seed</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">UnixNano</span>())
	<span style="color:#a6e22e">pIdx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Intn</span>(<span style="color:#a6e22e">l</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
	<span style="color:#a6e22e">pivot</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">pIdx</span>]
	<span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span> <span style="color:#75715e">// idx of element bigger than pivot
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">l</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>] &gt; <span style="color:#a6e22e">pivot</span> {
			<span style="color:#66d9ef">continue</span>
		}
		<span style="color:#a6e22e">swap</span>(<span style="color:#a6e22e">arr</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span>)
		<span style="color:#a6e22e">j</span><span style="color:#f92672">++</span>
	}
	<span style="color:#a6e22e">swap</span>(<span style="color:#a6e22e">arr</span>, <span style="color:#a6e22e">j</span>, <span style="color:#a6e22e">l</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
	<span style="color:#a6e22e">quickSortERand</span>(<span style="color:#a6e22e">arr</span>[:<span style="color:#a6e22e">j</span>])
	<span style="color:#a6e22e">quickSortERand</span>(<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:])
	<span style="color:#66d9ef">return</span>
}
</code></pre></div><h3 id="4-big-o-notation">4. Big O notation</h3>
<p>Quicksort is unique since its speed depends on the pivot we use.<br>
Here we can see the most common Big O run times.<br>
<img src="/posts/algorithm_illustration/images/big_o_times.png" alt="alt Big_O_Times"></p>
<p>Please pay attention to the example times in the chart because they are estimates of seconds per operation.<br>
Compared with Merged Sort, which is O(nlogn) and faster, quicksort is different:<br>
In the worst case, quicksorts takes O(n^2)time, which is as slow as selection sort.
In the average case, quicksorts takes O(nlogn)time.</p>
<h3 id="5-merge-sort-vs-quicksort">5. Merge Sort vs. Quicksort</h3>
<p>For algorithms with O(n), there are a constant for every operation.<br>
Commonly, the constant is ignored, however, it&rsquo;ll make a difference in some cases.</p>
<ul>
<li>Quick sort has a smaller constant than merge sort.</li>
</ul>
<blockquote>
<p>Therefore, if they&rsquo;re both O(nlogn)time, quicksort will be faster.
Besides, quicksort is faster in practice since it hits the average case way more often than the worst case.</p>
</blockquote>
<h3 id="6-averge-case-vs-worst-case">6. Averge case vs. Worst case</h3>
<p>The performance of quicksort is heavily affected by the pivot.
Suppose we always choose the first element as the pivot, and call quick with an sorted array.
Since quicksort doesn&rsquo;t to see whether the input array is already sorted, it will still try to sort it.</p>
<p>As we can see in the following figure:<br>
<img src="/posts/algorithm_illustration/images/quick_sort_worst_case.png" alt="quick_sort_worst_case"></p>
<p>Since we&rsquo;re not splitting the array into two parts, one of the sub-arrays is always empty.
As we always get O(n) in every level of the stack, we finally get O(n)*O(n)O(n^2)time.<br>
Therefore, the call stack is so long that it takes O(n^2) time.</p>
<p>On the other hand, if we make the middle element as the pivot, the call stack would be much shorter(O(logn).<br>
Therefore, we get operation time O(nlogn).  <br>
<img src="/posts/algorithm_illustration/images/quick_sort_best_case.png" alt="quick_sort_best_case"></p>
<ul>
<li>However, the best case is also the average case.</li>
<li>If we choose a random element in the array as the pivot, quicksort will have O(nlogn)time on average.</li>
</ul>
<pre><code>Thank you for your effort to read this part of this passage.
What are included in this passage are my study notes about algorithm.
If you want to know more details about it, I strongly recommend you this book: 
grokking algoriths: An illustrated guide for programmers and other curious people.
The author illustrate algorithms with pictures, which make people easily understand difficult questions.
</code></pre><h3 id="summary">Summary</h3>
<ul>
<li>D&amp;C works by splitting a problem into smaller parts. And the base case is usually an array with no or only one element.</li>
<li>Choosing a random element as the pivot can make quicksort complete in O(nlog n) time on average.</li>
<li>Quicksort is faster than merge sort since the constant in Big O notation matters.</li>
<li>Since O(log n) is pretty faster than O(n) with a large list, the constant never matters for simple search versus binary search.</li>
</ul>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
