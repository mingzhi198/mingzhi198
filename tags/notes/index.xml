<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>notes on Li. Mingzhi</title>
    <link>/tags/notes/</link>
    <description>Recent content in notes on Li. Mingzhi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 05 Mar 2021 19:00:52 +0800</lastBuildDate><atom:link href="/tags/notes/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>分布式: 2PC 理论</title>
      <link>/p/%E5%88%86%E5%B8%83%E5%BC%8F-2pc-%E7%90%86%E8%AE%BA/</link>
      <pubDate>Fri, 05 Mar 2021 19:00:52 +0800</pubDate>
      
      <guid>/p/%E5%88%86%E5%B8%83%E5%BC%8F-2pc-%E7%90%86%E8%AE%BA/</guid>
      <description>Statement  This article is my study notes about distributed systems. Please refer to the original work for more details and indicate the source for reprinting.  1. 2PC理论  参考
  </description>
    </item>
    
    <item>
      <title>分布式: BASE 理论</title>
      <link>/p/%E5%88%86%E5%B8%83%E5%BC%8F-base-%E7%90%86%E8%AE%BA/</link>
      <pubDate>Fri, 05 Mar 2021 19:00:52 +0800</pubDate>
      
      <guid>/p/%E5%88%86%E5%B8%83%E5%BC%8F-base-%E7%90%86%E8%AE%BA/</guid>
      <description>Statement  This article is my study notes about distributed systems. Please refer to the original work for more details and indicate the source for reprinting.  1. BASE理论 eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。
BASE是指:
基本可用（Basically Available） 软状态（ Soft State） 最终一致性（ Eventual Consistency）   基本可用（Basically Available）
分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。
电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。
这就是损失部分可用性的体现。
  软状态（ Soft State）
允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。
  最终一致性（ Eventual Consistency）
系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。
  2. ACID和BASE的区别与联系 ACID是传统数据库常用的设计理念，追求强一致性模型。
BASE支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性。
ACID和BASE代表了两种截然相反的设计哲学
在分布式系统设计的场景中，系统组件对一致性要求是不同的，因此ACID和BASE又会结合使用。</description>
    </item>
    
    <item>
      <title>分布式: CAP 定理</title>
      <link>/p/%E5%88%86%E5%B8%83%E5%BC%8F-cap-%E5%AE%9A%E7%90%86/</link>
      <pubDate>Fri, 05 Mar 2021 19:00:52 +0800</pubDate>
      
      <guid>/p/%E5%88%86%E5%B8%83%E5%BC%8F-cap-%E5%AE%9A%E7%90%86/</guid>
      <description>Statement  This article is my study notes about distributed systems. Please refer to the original work for more details and indicate the source for reprinting.  1. 什么是CAP定理 CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性） 这三个基本需求，最多只能同时满足其中的2个。   Consistency（一致性）
指数据在多个副本之间能够保持一致的特性（严格的一致性）
  Availability（可用性）
指系统提供的服务必须一直处于可用的状态，每次请求都能获取到非错的响应（不保证获取的数据为最新数据）
  Partition tolerance（分区容错性）
分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障
  分区 在分布式系统中，不同的节点分布在不同的子网络中，由于一些特殊的原因，这些子节点之间出现了网络不通的状态， 但他们的内部子网络是正常的。从而导致了整个系统的环境被切分成了若干个孤立的区域，这就是分区。 2. 原理 2.1 定义 根据CAP原则定义，系统的一致性、可用性和分区容错性细分如下：
一致性： N1和N2的数据库V之间的数据是否完全一样。 可用性： N1和N2的对外部的请求能否做出正常的响应。 分区容错性：N1和N2之间的网络是否互通。 2.2 异常情况 假设一种极端情况，N1和N2之间的网络断开了，我们要支持这种网络异常。
相当于要满足分区容错性，能不能同时满足一致性和可用性呢？还是说要对他们进行取舍？
 两种选择：  第一：牺牲数据一致性，保证可用性。响应旧的数据V0给用户。 第二：牺牲可用性，保证数据一致性。阻塞等待，直到网络连接恢复，数据更新操作M完成之后，再给用户响应最新的数据V1。 这个过程，证明了要满足分区容错性的分布式系统，只能在一致性和可用性两者中，选择其中一个。</description>
    </item>
    
    <item>
      <title>Note: Logic</title>
      <link>/p/note-logic/</link>
      <pubDate>Wed, 03 Mar 2021 19:00:52 +0800</pubDate>
      
      <guid>/p/note-logic/</guid>
      <description>1. 状态机: 两杯酒交互后的数量  调酒
两个杯子(B1, B2)分别装1000ml酒, B1装红酒, B2装白酒;
从B1倒100ml红酒到B2中;
再从B2倒出100ml酒(非均匀混合体)到B1中;
问题: B1中白酒多,还是B2中红酒多
答案: 一样多   status 1
B1装1000ml红酒, B2装1000ml白酒;     杯子 红酒 白酒     B1 1000 0   B2 0 1000     status 2
从B1倒100ml红酒到B2中;     杯子 红酒 白酒     B1 1000-(100)=900 0   B2 0+(100)=100 1000     step 3</description>
    </item>
    
    <item>
      <title>Note: Trees</title>
      <link>/p/note-trees/</link>
      <pubDate>Wed, 03 Mar 2021 19:00:52 +0800</pubDate>
      
      <guid>/p/note-trees/</guid>
      <description>二叉树, 二叉搜索树(BST), 平衡二叉树(AVL), 红黑树, B树,B+树  二叉树 无序插入, 当需要查找的时候，还是得一个一个挨着去遍历查找
二叉搜索树(BST) 插入的数据有序，左子树必须小于根节点，右子树必须大于根节点;
使用二分查找来提高效率
但是如果插入的顺序是升序或者降序的话，树的形状会变成如下：
此时二叉搜索树就会退化成链表，时间复杂度又会变成O(n)
平衡二叉树(AVL) 为了解决上述问题，通过左旋转或右旋转让树平衡
最短子树跟最长子树高度只差不能超过1
由图我们可以看到，当顺序插入的时候，会自动的进行旋转，以达到平衡
但是会通过插入性能的损失来弥补查询性能的提升
 当我们插入的数据很多时候，而查询很少的时候，由于插入数据会旋转同样会消耗很多时间  4. 红黑树 同样是经过左右旋让树平衡起来，还要变色的行为
最长子树只要不超过最短子树的两倍即可
查询性能和插入性能近似取得平衡
 但是随着数据的插入、发现树的深度会变深，树的深度会越来越深，意味着IO次数越多，影响数据读取的效率  5. B树 为了解决上述数据插入过多，树深度变深的问题，我们采用B树
把原来的有序二叉树变成有序多叉树
举例： 如果要查询select * from table where id=14？ 第一步，将磁盘一加载到内存中，发现14&amp;lt;16,寻找地址磁盘2 第二步，将磁盘二加载到内存中，发现14&amp;gt;11,寻找地址磁盘7 第三步，将磁盘七加载到内存中，发现14=14，读取data，取出data，结束  问题   B树不支持范围查询的快速查找  如果我们查询一个范围的数据，查找到范围一个边界时，需要回到根节点重新遍历查找，需要从根节点进行多次遍历，即便找到范围的另一个边界，查询效率会降低。 如果data存储的是行记录，行的大小随着列数的增多，所占空间会变大。  这时，一个页中可存储的数据量就会变少，树相应就会变高，磁盘IO次数就会变大。 6. B+树 B+树对B树进行了改进，把数据全放在了叶子节点中，叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。
例如： 查询范围 select * from table where id between 11 and 35？ 第一步，将磁盘一加载到内存中，发现11&amp;lt;28,寻找地址磁盘2 第二步，将磁盘二加载到内存中，发现10&amp;gt;11&amp;gt;17,寻找地址磁盘5 第三步，将磁盘五加载到内存中，发现11=11，读取data 第四步，继续向右查询，读取磁盘5，发现35=35，读取11-35之间数据，结束 由此可见，这样的范围查询比B树速度提高了不少  B+树相对B树的优点  1.</description>
    </item>
    
    <item>
      <title>Note: Network</title>
      <link>/p/note-network/</link>
      <pubDate>Mon, 01 Mar 2021 19:00:52 +0800</pubDate>
      
      <guid>/p/note-network/</guid>
      <description>http各版本的区别(http0.9, http1.0, http1.1, http2.0)  1. HTTP&amp;amp;HTTPS 1. HTTPS证书的申请流程  在服务器上生成CSR文件（证书申请文件，内容包括证书公钥、使用的Hash算法、申请的域名、公司名称、职位等信息） 把CSR文件和其他可能的证件上传到CA认证机构 CA机构收到证书申请之后，使用申请中的Hash算法，对部分内容进行摘要，然后使用CA机构自己的私钥对这段摘要信息进行签名  CA机构把签名过的证书通过发送给申请者。  2. HTTPs客户端和服务端的交互流程 1. 客户端向服务器发出加密通信的请求 (1) 支持的协议版本，比如 TLS 1.0 (2) 客户端生成的随机数 random1, 稍后用于生成 会话密钥 (3) 支持的加密算法， 比如RSA非对称加密 (4) 支持的压缩算法 2. 服务器收到请求，然后响应 (1) 确认使用的加密通信协议，比如 TLS 1.0版本。 若客户端与服务器支持的版本不一致，则服务器关闭加密通信。 (2) 服务器生成随机数 random2, 稍后用于生成 会话密钥 (3) 确认使用的加密方法，比如 RSA非对称加密 (4) 服务器的证书 3. 客户端验证服务器证书  验证流程  1. CA机构在签发证书的时候，用签名算法(sha256RSA)对证书内容进行摘要，用自己的私钥对摘要进行签名E 2. 浏览器用预置在系统中的CA机构的公钥对服务器证书进行验签：用CA机构的公钥解密签名后的摘要E 3. 验签通过后得到CA机构使用的证书摘要S 4. 浏览器用相同的签名算法对证书内容进行一次摘要S1，若得到的值S1与验证签之后得到的摘要S相同，则验签通过  生成随机密钥 pre-master secret  验证通过后，客户端生成一个随机数 pre-master secret, 然后用证书中的公钥进行加密，并传给服务端。 服务端端用私钥将其解密； 即客户端和服务端都有一套相同的数据：pre-master secret, random1, random2  pre-master secret  pre-master secret 前两个字节是TLS版本号。 在 Client 在第一次请求的时候会明文发送一份加密套件列表和当前支持的SSL/TLS版本号给服务端， 若服务端对密文中解密出来的pre-master版本号跟之前客户端发送的版本号不一致，则停止通信 4.</description>
    </item>
    
    <item>
      <title>Note: MySQL</title>
      <link>/p/note-mysql/</link>
      <pubDate>Fri, 26 Feb 2021 19:00:52 +0800</pubDate>
      
      <guid>/p/note-mysql/</guid>
      <description>[TOC]
1. 事务 1.1 事务的四个重要特性(ACID)：  原子性（Atomicity）   事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。  一致性（Consistency）   指事务将数据库从一种状态转变为另一种一致的的状态。事务开始前和结束后，数据库的完整性约束没有被破坏。 例如工号带有唯一属性，如果经过一个修改工号的事务后，工号变的非唯一了，则表明一致性遭到了破坏。  隔离性（Isolation）   要求每个读写事务的对象对其他事务的操作对象能互相分离，即该事务提交前对其他事务不可见。 也可以理解为多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。 注：MySQL 通过锁机制来保证事务的隔离性。  持久性（Durability）   事务一旦提交，则其结果就是永久性的 1.2 事务的隔离级别  SQL 标准定义的四种隔离级别被 ANSI（美国国家标准学会）和 ISO/IEC（国际标准）采用，每种级别对事务的处理能力会有不同程度的影响。  READ UNCOMMITTED（读未提交）   初始化测试数据库： SET @@session.transaction_isolation = &#39;READ-UNCOMMITTED&#39;; create database test; use test; create table test(id int primary key); insert into test(id) values(1); 1. 打开终端1，开启一个事务，修改ID为1的记录更新为2： SET @@session.transaction_isolation = &#39;READ-UNCOMMITTED&#39;; begin; update test set id = 2 where id = 1; select * from test; -- 此时看到一条ID为2的记录 2.</description>
    </item>
    
    <item>
      <title>Note: Redis</title>
      <link>/p/note-redis/</link>
      <pubDate>Fri, 26 Feb 2021 19:00:52 +0800</pubDate>
      
      <guid>/p/note-redis/</guid>
      <description>Redis   Redis数据类型及应用场景
  Redis进程模型及其高效原理
  Redis有序集的实现方式
  </description>
    </item>
    
  </channel>
</rss>
