<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='Statement  This article is my study notes about distributed systems. Please refer to the original work for more details and indicate the source for reprinting.   1. Goroutine Goroutine = Golang &#43; Coroutine。Goroutine是golang实现的协程，是用户级线程。
Goroutine具有以下特点：
 相比线程，其启动的代价很小，以很小栈空间启动（2Kb左右） 能够动态地伸缩栈的大小，最大可以支持到Gb级别 工作在用户态，切换成很小 与线程关系是n:m，即可以在n个系统线程上多工调度m个Goroutine  2. 进程、线程、Goroutine 在仅支持进程的操作系统中，进程是拥有资源和独立调度的基本单位。
在引入线程的操作系统中，线程是独立调度的基本单位，进程是资源拥有的基本单位。
线程创建、管理、调度等采用的方式称为线程模型。线程模型一般分为以下三种：
 内核级线程(Kernel Level Thread)模型 用户级线程(User Level Thread)模型 两级线程模型，也称混合型线程模型  三大线程模型最大差异就在于用户级线程与内核调度实体KSE（KSE，Kernel Scheduling Entity）之间的对应关系。
KSE是Kernel Scheduling Entity的缩写，其是可被操作系统内核调度器调度的对象实体，是操作系统内核的最小调度单元，可以简单理解为内核级线程。
用户级线程即协程，由应用程序创建与管理，协程必须与内核级线程绑定之后才能执行。
线程由 CPU 调度是抢占式的，协程由用户态调度是协作式的，一个协程让出 CPU 后，才执行下一个协程。
3. Golang的线程模型 Golang在底层实现了混合型线程模型。M即系统线程，由系统调用产生，一个M关联一个KSE，即两级线程模型中的系统线程。G为Groutine，即两级线程模型的的应用及线程。M与G的关系是N:M。'><title>Golang: GMP调度模型</title>

<link rel='canonical' href='/p/golang-gmp%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='Golang: GMP调度模型'>
<meta property='og:description' content='Statement  This article is my study notes about distributed systems. Please refer to the original work for more details and indicate the source for reprinting.   1. Goroutine Goroutine = Golang &#43; Coroutine。Goroutine是golang实现的协程，是用户级线程。
Goroutine具有以下特点：
 相比线程，其启动的代价很小，以很小栈空间启动（2Kb左右） 能够动态地伸缩栈的大小，最大可以支持到Gb级别 工作在用户态，切换成很小 与线程关系是n:m，即可以在n个系统线程上多工调度m个Goroutine  2. 进程、线程、Goroutine 在仅支持进程的操作系统中，进程是拥有资源和独立调度的基本单位。
在引入线程的操作系统中，线程是独立调度的基本单位，进程是资源拥有的基本单位。
线程创建、管理、调度等采用的方式称为线程模型。线程模型一般分为以下三种：
 内核级线程(Kernel Level Thread)模型 用户级线程(User Level Thread)模型 两级线程模型，也称混合型线程模型  三大线程模型最大差异就在于用户级线程与内核调度实体KSE（KSE，Kernel Scheduling Entity）之间的对应关系。
KSE是Kernel Scheduling Entity的缩写，其是可被操作系统内核调度器调度的对象实体，是操作系统内核的最小调度单元，可以简单理解为内核级线程。
用户级线程即协程，由应用程序创建与管理，协程必须与内核级线程绑定之后才能执行。
线程由 CPU 调度是抢占式的，协程由用户态调度是协作式的，一个协程让出 CPU 后，才执行下一个协程。
3. Golang的线程模型 Golang在底层实现了混合型线程模型。M即系统线程，由系统调用产生，一个M关联一个KSE，即两级线程模型中的系统线程。G为Groutine，即两级线程模型的的应用及线程。M与G的关系是N:M。'>
<meta property='og:url' content='/p/golang-gmp%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B/'>
<meta property='og:site_name' content='Li. Mingzhi'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='notes' /><meta property='article:tag' content='cap' /><meta property='article:tag' content='districuted system' /><meta property='article:published_time' content='2021-03-08T15:00:52&#43;08:00'/><meta property='article:modified_time' content='2021-03-08T15:00:52&#43;08:00'/>
<meta name="twitter:title" content="Golang: GMP调度模型">
<meta name="twitter:description" content="Statement  This article is my study notes about distributed systems. Please refer to the original work for more details and indicate the source for reprinting.   1. Goroutine Goroutine = Golang &#43; Coroutine。Goroutine是golang实现的协程，是用户级线程。
Goroutine具有以下特点：
 相比线程，其启动的代价很小，以很小栈空间启动（2Kb左右） 能够动态地伸缩栈的大小，最大可以支持到Gb级别 工作在用户态，切换成很小 与线程关系是n:m，即可以在n个系统线程上多工调度m个Goroutine  2. 进程、线程、Goroutine 在仅支持进程的操作系统中，进程是拥有资源和独立调度的基本单位。
在引入线程的操作系统中，线程是独立调度的基本单位，进程是资源拥有的基本单位。
线程创建、管理、调度等采用的方式称为线程模型。线程模型一般分为以下三种：
 内核级线程(Kernel Level Thread)模型 用户级线程(User Level Thread)模型 两级线程模型，也称混合型线程模型  三大线程模型最大差异就在于用户级线程与内核调度实体KSE（KSE，Kernel Scheduling Entity）之间的对应关系。
KSE是Kernel Scheduling Entity的缩写，其是可被操作系统内核调度器调度的对象实体，是操作系统内核的最小调度单元，可以简单理解为内核级线程。
用户级线程即协程，由应用程序创建与管理，协程必须与内核级线程绑定之后才能执行。
线程由 CPU 调度是抢占式的，协程由用户态调度是协作式的，一个协程让出 CPU 后，才执行下一个协程。
3. Golang的线程模型 Golang在底层实现了混合型线程模型。M即系统线程，由系统调用产生，一个M关联一个KSE，即两级线程模型中的系统线程。G为Groutine，即两级线程模型的的应用及线程。M与G的关系是N:M。">
    </head>
    <body class="">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            localStorage.setItem(colorSchemeKey, "auto");
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.body.dataset.scheme = 'dark';
        } else {
            document.body.dataset.scheme = 'light';
        }
    })();
</script><div class="container main-container flex on-phone--column extended article-page with-toolbar">
            <aside class="sidebar left-sidebar sticky">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header class="site-info">
        
            <figure class="site-avatar">
                
                    
                    
                    
                        
                        <img src="/images/avatar_hu293ca6c6e78e5e0367766a16589f1967_47660_300x0_resize_q75_box.jpeg" width="300"
                            height="405" class="site-logo" loading="lazy" alt="Avatar">
                    
                

                
            </figure>
        
        <h1 class="site-name"><a href="">Li. Mingzhi</a></h1>
        <h2 class="site-description">I am a Backend Software Engineer focusing on system design and algorithm(^_^). 
        Progress one percent per day...</h2>
    </header>

    <ol class="menu" id="main-menu">
        
        
        

        <li >
            <a href='/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        

        <li >
            <a href='/p/resume/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>About Me</span>
            </a>
        </li>
        
        

        <li >
            <a href='/archives/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        

        <li >
            <a href='/search/index.html'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        

        
    </ol>
</aside>

            <main class="main full-width">
    <div id="article-toolbar">
        <a href="" class="back-home">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



            <span>Back</span>
        </a>
    </div>

    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/notes/" >
                notes
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/golang-gmp%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B/">Golang: GMP调度模型</a>
    </h2>

    <footer class="article-time">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <time class="article-time--published">Mar 08, 2021</time>
    </footer></div>
</header>

    <section class="article-content">
    <h1 id="statement">Statement</h1>
<ul>
<li>This article is my study notes about distributed systems.</li>
<li>Please refer to the original work for more details and indicate the source for reprinting.</li>
</ul>
<hr>
<h2 id="1-goroutine">1. Goroutine</h2>
<p>Goroutine = Golang + Coroutine。Goroutine是golang实现的协程，是用户级线程。<br>
Goroutine具有以下特点：</p>
<ul>
<li>相比线程，其启动的代价很小，以很小栈空间启动（2Kb左右）</li>
<li>能够动态地伸缩栈的大小，最大可以支持到Gb级别</li>
<li>工作在用户态，切换成很小</li>
<li>与线程关系是n:m，即可以在n个系统线程上多工调度m个Goroutine</li>
</ul>
<h2 id="2-进程线程goroutine">2. 进程、线程、Goroutine</h2>
<p>在仅支持进程的操作系统中，进程是拥有资源和独立调度的基本单位。<br>
在引入线程的操作系统中，线程是独立调度的基本单位，进程是资源拥有的基本单位。</p>
<p>线程创建、管理、调度等采用的方式称为线程模型。线程模型一般分为以下三种：</p>
<ul>
<li>内核级线程(Kernel Level Thread)模型</li>
<li>用户级线程(User Level Thread)模型</li>
<li>两级线程模型，也称混合型线程模型</li>
</ul>
<p>三大线程模型最大差异就在于用户级线程与内核调度实体KSE（KSE，Kernel Scheduling Entity）之间的对应关系。<br>
KSE是Kernel Scheduling Entity的缩写，其是可被操作系统内核调度器调度的对象实体，是操作系统内核的最小调度单元，可以简单理解为内核级线程。</p>
<p>用户级线程即协程，由应用程序创建与管理，协程必须与内核级线程绑定之后才能执行。<br>
线程由 CPU 调度是抢占式的，协程由用户态调度是协作式的，一个协程让出 CPU 后，才执行下一个协程。</p>
<h2 id="3-golang的线程模型">3. Golang的线程模型</h2>
<p>Golang在底层实现了混合型线程模型。M即系统线程，由系统调用产生，一个M关联一个KSE，即两级线程模型中的系统线程。G为Groutine，即两级线程模型的的应用及线程。M与G的关系是N:M。</p>
<p><img src="/post/golang/images/go_thread_model.image" alt="golang_thread_model"  /></p>
<h2 id="4-gmp模型">4. GMP模型</h2>
<p>M指的是Machine，一个M直接关联了一个内核线程。<br>
P指的是”processor”，代表了M所需的上下文环境，也是处理用户级代码逻辑的处理器。P关联了的本地可运行G的队列(也称为LRQ)，最多可存放256个G。<br>
G指的是Goroutine，其实本质上也是一种轻量级的线程。</p>
<p><img src="/post/golang/images/gmp_model.image" alt="gpm"  /></p>
<p>GMP调度流程大致如下：</p>
<ul>
<li>线程M想运行任务就需得获取 P，即与P关联。</li>
<li>然后从 P 的本地队列(LRQ)获取 G</li>
<li>若LRQ中没有可运行的G，M 会尝试从全局队列(GRQ)拿一批G放到P的本地队列，</li>
<li>若全局队列也未找到可运行的G时候，M会随机从其他 P 的本地队列偷一半放到自己 P 的本地队列。</li>
<li>拿到可运行的G之后，M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。</li>
</ul>
<h2 id="5-调度的生命周期">5. 调度的生命周期</h2>
<p><img src="/post/golang/images/gmp_schedule.image" alt="gpm_schedule"  /></p>
<ul>
<li>M0 是启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，<br>
M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了</li>
<li>G0 是每次启动一个 M 都会第一个创建的 gourtine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0。</li>
<li>在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0</li>
</ul>
<p>上面生命周期流程说明：</p>
<ul>
<li>runtime 创建最初的线程 m0 和 goroutine g0，并把两者进行关联（g0.m = m0)</li>
<li>调度器初始化：设置M最大数量，P个数，栈和内存初始化，以及创建 GOMAXPROCS个P</li>
</ul>
<pre><code>示例代码中的 main 函数是 main.main，runtime 中也有 1 个 main 函数 ——runtime.main，
代码经过编译后，runtime.main 会调用 main.main，
程序启动时会为 runtime.main 创建 goroutine，我们称它为 main goroutine，
然后把 main goroutine 加入到 P 的本地队列。
</code></pre><ul>
<li>启动 m0，m0 已经绑定了 P，会从 P 的本地队列获取 G，获取到 main goroutine。</li>
<li>G 拥有栈，M 根据 G 中的栈信息和调度信息设置运行环境</li>
<li>M 运行 G</li>
<li>G 退出，再次回到 M 获取可运行的 G，这样重复下去，直到 main.main 退出，runtime.main 执行 Defer 和 Panic 处理，或调用 runtime.exit 退出程序。</li>
</ul>
<h2 id="6-g-m-p的数量">6. G-M-P的数量</h2>
<h3 id="61-g-的数量">6.1 G 的数量</h3>
<p>理论上没有数量上限限制的。查看当前G的数量可以使用runtime. NumGoroutine()</p>
<h3 id="62-p-的数量">6.2 P 的数量</h3>
<p>由启动时环境变量 $GOMAXPROCS 或者是由runtime.GOMAXPROCS() 决定。这意味着在程序执行的任意时刻都只有 $GOMAXPROCS 个 goroutine 在同时运行。</p>
<h3 id="63-m-的数量">6.3 M 的数量:</h3>
<p>go 语言本身的限制：go 程序启动时，会设置 M 的最大数量，默认 10000. 但是内核很难支持这么多的线程数，所以这个限制可以忽略。<br>
可以通过runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量<br>
一个 M 阻塞了，会创建新的 M。M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来。</p>
<h2 id="7-调度的流程状态">7. 调度的流程状态</h2>
<p><img src="/post/golang/images/gmp_schedule.image" alt="gmp_schedule"  /></p>
<p>从上图我们可以看出来：</p>
<ul>
<li>每个P有个局部队列，局部队列保存待执行的goroutine(流程2)，当M绑定的P的的局部队列已经满了之后就会把goroutine放到全局队列(流程2-1)</li>
<li>每个P和一个M绑定，M是真正的执行P中goroutine的实体(流程3)，M从绑定的P中的局部队列获取G来执行</li>
<li>当M绑定的P的局部队列为空时，M会从全局队列获取到本地队列来执行G(流程3.1)，当从全局队列中没有获取到可执行的G时候，M会从其他P的局部队列中偷取G来执行(流程3.2)，这种从其他P偷的方式称为work stealing</li>
<li>当G因系统调用(syscall)阻塞时会阻塞M，此时P会和M解绑即hand off，并寻找新的idle的M，若没有idle的M就会新建一个M(流程5.1)。</li>
<li>当G因channel或者network I/O阻塞时，不会阻塞M，M会寻找其他runnable的G；当阻塞的G恢复后会重新进入runnable进入P队列等待执行(流程5.3)</li>
</ul>
<h2 id="8-调度过程中阻塞">8. 调度过程中阻塞</h2>
<p>MP模型的阻塞可能发生在下面几种情况：</p>
<ul>
<li>I/O，select</li>
<li>block on syscall</li>
<li>channel</li>
<li>等待锁</li>
<li>runtime.Gosched()</li>
</ul>
<h3 id="81-用户态阻塞">8.1 用户态阻塞</h3>
<p>当goroutine因为channel操作或者network I/O而阻塞时（实际上golang已经用netpoller实现了goroutine网络I/O, 阻塞不会导致M被阻塞，仅阻塞G），<br>
对应的G会被放置到某个wait队列(如channel的waitq)，该G的状态由_Gruning变为_Gwaitting，<br>
而M会跳过该G尝试获取并执行下一个G，如果此时没有runnable的G供M运行，那么M将解绑P，并进入sleep状态；<br>
当阻塞的G被另一端的G2唤醒时（比如channel的可读/写通知），G被标记为runnable，尝试加入G2所在P的runnext，然后再是P的Local队列和Global队列。</p>
<h3 id="83-系统调用阻塞">8.3 系统调用阻塞</h3>
<p>当G被阻塞在某个系统调用上时，此时G会阻塞在_Gsyscall状态，M也处于 block on syscall 状态，<br>
此时的M可被抢占调度：执行该G的M会与P解绑，而P则尝试与其它idle的M绑定，继续执行其它G。<br>
如果没有其它idle的M，但P的Local队列中仍然有G需要执行，则创建一个新的M；<br>
当系统调用完成后，G会重新尝试获取一个idle的P进入它的Local队列恢复执行，<br>
如果没有idle的P，G会被标记为runnable加入到Global队列。</p>
<h2 id="9-g-m-p内部结构">9. G-M-P内部结构</h2>
<h3 id="91-g的内部结构">9.1 G的内部结构</h3>
<p>G的部分内部结构中重要字段如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-Golang" data-lang="Golang"><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">stack</span>       <span class="nx">stack</span>   <span class="c1">// g自己的栈
</span><span class="c1"></span>    <span class="nx">m</span>            <span class="o">*</span><span class="nx">m</span>      <span class="c1">// 隶属于哪个M
</span><span class="c1"></span>    <span class="nx">sched</span>        <span class="nx">gobuf</span>   <span class="c1">// 保存了g的现场，goroutine切换时通过它来恢复
</span><span class="c1"></span>    <span class="nx">atomicstatus</span> <span class="kt">uint32</span>  <span class="c1">// G的运行状态
</span><span class="c1"></span>    <span class="nx">goid</span>         <span class="kt">int64</span>
    <span class="nx">schedlink</span>    <span class="nx">guintptr</span> <span class="c1">// 下一个g, g链表
</span><span class="c1"></span>    <span class="nx">preempt</span>      <span class="kt">bool</span> <span class="c1">//抢占标记
</span><span class="c1"></span>    <span class="nx">lockedm</span>      <span class="nx">muintptr</span> <span class="c1">// 锁定的M, g中断恢复指定M执行
</span><span class="c1"></span>    <span class="nx">gopc</span>          <span class="kt">uintptr</span>  <span class="c1">// 创建该goroutine的指令地址
</span><span class="c1"></span>    <span class="nx">startpc</span>       <span class="kt">uintptr</span>  <span class="c1">// goroutine 函数的指令地址
</span><span class="c1"></span>    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>G的状态有以下9种:</p>
<table>
<thead>
<tr>
<th>status</th>
<th>value</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>_Gidle</td>
<td>0</td>
<td>刚刚被分配，还没有进行初始化。</td>
</tr>
<tr>
<td>_Grunnable</td>
<td>1</td>
<td>已经在运行队列中，还没有执行用户代码。</td>
</tr>
<tr>
<td>_Grunning</td>
<td>2</td>
<td>不在运行队列里中，已经可以执行用户代码，此时已经分配了 M 和 P。</td>
</tr>
<tr>
<td>_Gsyscall</td>
<td>3</td>
<td>正在执行系统调用，此时分配了 M。</td>
</tr>
<tr>
<td>_Gwaiting</td>
<td>4</td>
<td>在运行时被阻止，没有执行用户代码，也不在运行队列中，此时它正在某处阻塞等待中。</td>
</tr>
<tr>
<td>_Gmoribund_unused</td>
<td>5</td>
<td>尚未使用，但是在 gdb 中进行了硬编码。</td>
</tr>
<tr>
<td>_Gdead</td>
<td>6</td>
<td>尚未使用，这个状态可能是刚退出或是刚被初始化，此时它并没有执行用户代码，有可能有也有可能没有分配堆栈。</td>
</tr>
<tr>
<td>_Genqueue_unused</td>
<td>7</td>
<td>尚未使用。</td>
</tr>
<tr>
<td>_Gcopystack</td>
<td>8</td>
<td>正在复制堆栈，并没有执行用户代码，也不在运行队列中。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>G状态定义代码位置:　runtime/runtime2.go</p>
</blockquote>
<h3 id="92-m的结构">9.2 M的结构</h3>
<p>M的部分内部结构:</p>
<div class="highlight"><pre class="chroma"><code class="language-Golang" data-lang="Golang"><span class="kd">type</span> <span class="nx">m</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">g0</span>            <span class="o">*</span><span class="nx">g</span>        <span class="c1">// g0, 每个M都有自己独有的g0
</span><span class="c1"></span>    <span class="nx">curg</span>          <span class="o">*</span><span class="nx">g</span>        <span class="c1">// 当前正在运行的g
</span><span class="c1"></span>    <span class="nx">p</span>             <span class="nx">puintptr</span>  <span class="c1">// 隶属于哪个P
</span><span class="c1"></span>    <span class="nx">nextp</span>         <span class="nx">puintptr</span>  <span class="c1">// 当m被唤醒时，首先拥有这个p
</span><span class="c1"></span>    <span class="nx">id</span>            <span class="kt">int64</span>
    <span class="nx">spinning</span>      <span class="kt">bool</span>      <span class="c1">// 是否处于自旋
</span><span class="c1"></span>
    <span class="nx">park</span>          <span class="nx">note</span>
    <span class="nx">alllink</span>       <span class="o">*</span><span class="nx">m</span>        <span class="c1">// on allm
</span><span class="c1"></span>    <span class="nx">schedlink</span>     <span class="nx">muintptr</span>  <span class="c1">// 下一个m, m链表
</span><span class="c1"></span>    <span class="nx">mcache</span>        <span class="o">*</span><span class="nx">mcache</span>   <span class="c1">// 内存分配
</span><span class="c1"></span>    <span class="nx">lockedg</span>       <span class="nx">guintptr</span>  <span class="c1">// 和 G 的lockedm对应
</span><span class="c1"></span>    <span class="nx">freelink</span>      <span class="o">*</span><span class="nx">m</span>        <span class="c1">// on sched.freem
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h3 id="93-p的内部结构">9.3 P的内部结构</h3>
<p>P的部分内部结构:</p>
<div class="highlight"><pre class="chroma"><code class="language-Golang" data-lang="Golang"><span class="kd">type</span> <span class="nx">p</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">id</span>          <span class="kt">int32</span>
    <span class="nx">status</span>      <span class="kt">uint32</span>    <span class="c1">// P的状态
</span><span class="c1"></span>    <span class="nx">link</span>        <span class="nx">puintptr</span>  <span class="c1">// 下一个P, P链表
</span><span class="c1"></span>    <span class="nx">m</span>           <span class="nx">muintptr</span>  <span class="c1">// 拥有这个P的M
</span><span class="c1"></span>    <span class="nx">mcache</span>      <span class="o">*</span><span class="nx">mcache</span>

    <span class="c1">// P本地runnable状态的G队列，无锁访问
</span><span class="c1"></span>    <span class="nx">runqhead</span> <span class="kt">uint32</span>
    <span class="nx">runqtail</span> <span class="kt">uint32</span>
    <span class="nx">runq</span>     <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="nx">guintptr</span>

    <span class="nx">runnext</span> <span class="nx">guintptr</span> <span class="c1">// 一个比runq优先级更高的runnable G
</span><span class="c1"></span>
    <span class="c1">// 状态为dead的G链表，在获取G时会从这里面获取
</span><span class="c1"></span>    <span class="nx">gFree</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">gList</span>
        <span class="nx">n</span> <span class="kt">int32</span>
    <span class="p">}</span>
    <span class="c1">// gcw is this P&#39;s GC work buffer cache. The work buffer is
</span><span class="c1"></span>    <span class="c1">// filled by write barriers, drained by mutator assists, and
</span><span class="c1"></span>    <span class="c1">// disposed on certain GC state transitions.
</span><span class="c1"></span>    <span class="nx">gcw</span> <span class="nx">gcWork</span>
<span class="p">}</span>
</code></pre></div><h3 id="94-调度器的内部结构">9.4 调度器的内部结构</h3>
<p>调度器部分内部结构</p>
<div class="highlight"><pre class="chroma"><code class="language-Golang" data-lang="Golang"><span class="kd">type</span> <span class="nx">schedt</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// accessed atomically. keep at top to ensure alignment on 32-bit systems.
</span><span class="c1"></span>    <span class="nx">lock</span> <span class="nx">mutex</span>
    <span class="nx">midle</span>        <span class="nx">muintptr</span> <span class="c1">// 空闲M链表
</span><span class="c1"></span>    <span class="nx">nmidle</span>       <span class="kt">int32</span>    <span class="c1">// 空闲M数量
</span><span class="c1"></span>    <span class="nx">nmidlelocked</span> <span class="kt">int32</span>    <span class="c1">// 被锁住的M的数量
</span><span class="c1"></span>    <span class="nx">mnext</span>        <span class="kt">int64</span>    <span class="c1">// 已创建M的数量，以及下一个M ID
</span><span class="c1"></span>    <span class="nx">maxmcount</span>    <span class="kt">int32</span>    <span class="c1">// 允许创建最大的M数量
</span><span class="c1"></span>    <span class="nx">nmsys</span>        <span class="kt">int32</span>    <span class="c1">// 不计入死锁的M数量
</span><span class="c1"></span>    <span class="nx">nmfreed</span>      <span class="kt">int64</span>    <span class="c1">// 累计释放M的数量
</span><span class="c1"></span>    <span class="nx">pidle</span>        <span class="nx">puintptr</span> <span class="c1">// 空闲的P链表
</span><span class="c1"></span>    <span class="nx">npidle</span>       <span class="kt">uint32</span>   <span class="c1">// 空闲的P数量
</span><span class="c1"></span>    <span class="nx">runq</span>         <span class="nx">gQueue</span>   <span class="c1">// 全局runnable的G队列
</span><span class="c1"></span>    <span class="nx">runqsize</span>     <span class="kt">int32</span>    <span class="c1">// 全局runnable的G数量
</span><span class="c1"></span>
    <span class="c1">// Global cache of dead G&#39;s.
</span><span class="c1"></span>    <span class="nx">gFree</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">lock</span>    <span class="nx">mutex</span>
        <span class="nx">stack</span>   <span class="nx">gList</span> <span class="c1">// Gs with stacks
</span><span class="c1"></span>        <span class="nx">noStack</span> <span class="nx">gList</span> <span class="c1">// Gs without stacks
</span><span class="c1"></span>        <span class="nx">n</span>       <span class="kt">int32</span>
    <span class="p">}</span>

    <span class="c1">// freem is the list of m&#39;s waiting to be freed when their
</span><span class="c1"></span>    <span class="c1">// m.exited is set. Linked through m.freelink.
</span><span class="c1"></span>    <span class="nx">freem</span> <span class="o">*</span><span class="nx">m</span>
<span class="p">}</span>
</code></pre></div><h2 id="10-观察调度流程">10. 观察调度流程</h2>
<h3 id="101-godebug-trace方式">10.1 GODEBUG trace方式</h3>
<p>GODEBUG 变量可以控制运行时内的调试变量，参数以逗号分隔，格式为：name=val。<br>
观察GMP可以使用下面两个参数：</p>
<ul>
<li>schedtrace：设置 schedtrace=X 参数可以使运行时在每 X 毫秒输出一行调度器的摘要信息到标准 err 输出中。</li>
<li>scheddetail：设置 schedtrace=X 和 scheddetail=1 可以使运行时在每 X 毫秒输出一次详细的多行信息，信息内容主要包括调度程序、处理器、OS 线程 和 Goroutine 的状态。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-Golang" data-lang="Golang"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">debugTrace</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">2000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">a</span> <span class="o">:=</span> <span class="mi">0</span>
			<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mf">1e6</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
				<span class="nx">a</span> <span class="o">+=</span> <span class="mi">1</span>
			<span class="p">}</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}()</span>

		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>执行一下命令：</p>
<blockquote>
<p>GODEBUG=schedtrace=1000 go run ./test.go</p>
</blockquote>
<p>输出内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Shell" data-lang="Shell">SCHED 0ms: <span class="nv">gomaxprocs</span><span class="o">=</span><span class="m">8</span> <span class="nv">idleprocs</span><span class="o">=</span><span class="m">7</span> <span class="nv">threads</span><span class="o">=</span><span class="m">5</span> <span class="nv">spinningthreads</span><span class="o">=</span><span class="m">0</span> <span class="nv">idlethreads</span><span class="o">=</span><span class="m">3</span> <span class="nv">runqueue</span><span class="o">=</span><span class="m">0</span> <span class="o">[</span><span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> 0<span class="o">]</span>
SCHED 1009ms: <span class="nv">gomaxprocs</span><span class="o">=</span><span class="m">8</span> <span class="nv">idleprocs</span><span class="o">=</span><span class="m">8</span> <span class="nv">threads</span><span class="o">=</span><span class="m">5</span> <span class="nv">spinningthreads</span><span class="o">=</span><span class="m">0</span> <span class="nv">idlethreads</span><span class="o">=</span><span class="m">3</span> <span class="nv">runqueue</span><span class="o">=</span><span class="m">0</span> <span class="o">[</span><span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> 0<span class="o">]</span>
SCHED 2013ms: <span class="nv">gomaxprocs</span><span class="o">=</span><span class="m">8</span> <span class="nv">idleprocs</span><span class="o">=</span><span class="m">8</span> <span class="nv">threads</span><span class="o">=</span><span class="m">5</span> <span class="nv">spinningthreads</span><span class="o">=</span><span class="m">0</span> <span class="nv">idlethreads</span><span class="o">=</span><span class="m">3</span> <span class="nv">runqueue</span><span class="o">=</span><span class="m">0</span> <span class="o">[</span><span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> 0<span class="o">]</span>
SCHED 3015ms: <span class="nv">gomaxprocs</span><span class="o">=</span><span class="m">8</span> <span class="nv">idleprocs</span><span class="o">=</span><span class="m">8</span> <span class="nv">threads</span><span class="o">=</span><span class="m">5</span> <span class="nv">spinningthreads</span><span class="o">=</span><span class="m">0</span> <span class="nv">idlethreads</span><span class="o">=</span><span class="m">3</span> <span class="nv">runqueue</span><span class="o">=</span><span class="m">0</span> <span class="o">[</span><span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> 0<span class="o">]</span>
</code></pre></div><p><img src="/post/golang/images/gmp_sched_trace.png" alt="gmp_sched_trace"  /></p>
<p>输出内容解释说明：</p>
<ul>
<li>SCHED XXms: SCHED是调度日志输出标志符。XXms是自程序启动之后到输出当前行时间</li>
<li>gomaxprocs： P的数量，等于当前的 CPU 核心数，或者GOMAXPROCS环境变量的值</li>
<li>idleprocs： 空闲P的数量，与gomaxprocs的差值即运行中P的数量</li>
<li>threads： 线程数量，即M的数量</li>
<li>spinningthreads：自旋状态线程的数量。当M没有找到可供其调度执行的 Goroutine 时，该线程并不会销毁，而是出于自旋状态</li>
<li>idlethreads：空闲线程的数量</li>
<li>runqueue：全局队列中G的数量</li>
<li>[0]：表示P本地队列下G的数量，有几个P中括号里面就会有几个数字</li>
</ul>
<h3 id="102-go-tool-trace方式">10.2 Go tool trace方式</h3>
<div class="highlight"><pre class="chroma"><code class="language-Golang" data-lang="Golang">
<span class="kd">func</span> <span class="nf">toolTrace</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// create trace file
</span><span class="c1"></span>	<span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="s">&#34;trace.out&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="kc">nil</span> <span class="o">!=</span> <span class="nx">err</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="c1">// start trace goroutine
</span><span class="c1"></span>	<span class="nx">err</span> <span class="p">=</span> <span class="nx">trace</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
	<span class="k">if</span> <span class="kc">nil</span> <span class="o">!=</span> <span class="nx">err</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">trace</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello trace&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>编译并运行程序生成trace文件trace.out<br>
执行下面命令，打开浏览器查看。</p>
<blockquote>
<p>go tool trace trace.out<br>
<img src="/post/golang/images/gmp_tool_trace.png" alt="gmp_trace_tool"  /></p>
</blockquote>
<p>点击Goroutine analysis:</p>
<p><img src="/post/golang/images/gmp_tool_trace_analysis.png" alt="gmp_trace_tool_goroutine_analysis"  /></p>
<h2 id="11-总结">11. 总结</h2>
<ol>
<li>Golang的线程模型采用的是混合型线程模型，线程与协程关系是N:M。</li>
<li>Golang混合型线程模型实现采用GMP模型进行调度，G是goroutine，是golang实现的协程，M是OS线程，P是逻辑处理器。</li>
<li>每一个M都需要与一个P绑定，P拥有本地可运行的G队列，M是执行G的单元，<br>
M获取可运行G流程是先从P的本地队列获取，<br>
若未获取到，则从其他P偷取过来（即work steal)，<br>
若其他的P也没有则从全局G队列获取，<br>
若都未获取到，则M将处于自旋状态，并不会销毁。</li>
<li>当执行G时候，发生用户级别阻塞(通道阻塞等)的时候，此时M不会阻塞，M会继续寻找其他可运行的G，<br>
当阻塞的G恢复之后，重新进入P的队列等待执行，<br>
若G进行系统调用的时候，会阻塞M，此时P会和M解绑(即hand off)，并寻找新的空闲的M。<br>
若没有空闲的就会创建一个新的M。</li>
<li>Work Steal和Hand Off保证了线程的高效利用。</li>
</ol>
<h3 id="g-m-p高效的保证策略有">G-M-P高效的保证策略有：</h3>
<ul>
<li>
<p>M是可以复用的，不需要反复创建与销毁，当没有可执行的Goroutine时候就处于自旋状态，等待唤醒</p>
</li>
<li>
<p>Work Stealing和Hand Off策略保证了M的高效利用</p>
<ul>
<li>内存分配状态(mcache)位于P，G可以跨M调度，不再存在跨M调度局部性差的问题(??? 此句我还不太明白, 后续补充)</li>
</ul>
</li>
<li>
<p>M从关联的P中获取G，不需要使用锁，是lock free的</p>
</li>
<li>
<p>参考<br>
<a class="link" href="https://juejin.cn/post/6886321367604527112"  target="_blank" rel="noopener"
    >https://juejin.cn/post/6886321367604527112</a><br>
<a class="link" href="https://i6448038.github.io/2017/12/04/golang-concurrency-principle/"  target="_blank" rel="noopener"
    >https://i6448038.github.io/2017/12/04/golang-concurrency-principle/</a></p>
</li>
</ul>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/notes/">notes</a>
        
            <a href="/tags/cap/">cap</a>
        
            <a href="/tags/districuted-system/">districuted system</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>

    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/p/golang-channel%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/">
        
        

        <div class="article-details">
            <h2 class="article-title">Golang: Channel底层实现</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E5%88%86%E5%B8%83%E5%BC%8F-base-%E7%90%86%E8%AE%BA/">
        
        

        <div class="article-details">
            <h2 class="article-title">分布式: BASE 理论</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E5%88%86%E5%B8%83%E5%BC%8F-cap-%E5%AE%9A%E7%90%86/">
        
        

        <div class="article-details">
            <h2 class="article-title">分布式: CAP 定理</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEraft/">
        
        

        <div class="article-details">
            <h2 class="article-title">分布式: 一致性协议Raft</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E5%88%86%E5%B8%83%E5%BC%8F-2pc%E7%90%86%E8%AE%BA/">
        
        

        <div class="article-details">
            <h2 class="article-title">分布式: 2PC理论</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>


    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2021 Li. Mingzhi
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="2.2.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >
            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
