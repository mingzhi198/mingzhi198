<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='Statement  这篇文件是我从这本书中的学习笔记: MySQL技术内幕（InnoDB存储引擎）. 非商业用途转载请注明出处，若要更详细了解书中内容，请参考原作。  1. InnoDB体系结构 InnoDB存储引擎有多个内存块组成的一个大的内存池，负责如下工作：
 维护所有进程/线程要访问的内部数据结构 缓存磁盘上的数据 重做日志(redo log)缓冲  1.1. 后台线程  Master Thread  核心线程，负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性 IO Thread
InnoDB存储引擎大量使用了AIO（Async IO)来处理写IO请求；
InnoDB 1.0版本之前共有4个IO Thread: write, read, insert buffer and log IO thread   查看InnoDB中的 IO Thread:
 show engine innodb status\G 3. Purge Thread
事务被提交后，其所使用的undolog可能不再需要，Purge Thread可以回收已经使用并分配的undo页。
从InnoDB 1.2版本开始，支持多个 Purge Thread, 从而加入undo页的回收；
另外 Purge Thread 离散地读取 undo 页，可以利用磁盘的随机读取性能。
mysql root@127.0.0.1:test&amp;gt; show variables like &amp;#39;innodb_purge_threads&amp;#39; \G ***************************[ 1.'><title>cp2. InnoDB</title>

<link rel='canonical' href='/p/cp2.-innodb/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='cp2. InnoDB'>
<meta property='og:description' content='Statement  这篇文件是我从这本书中的学习笔记: MySQL技术内幕（InnoDB存储引擎）. 非商业用途转载请注明出处，若要更详细了解书中内容，请参考原作。  1. InnoDB体系结构 InnoDB存储引擎有多个内存块组成的一个大的内存池，负责如下工作：
 维护所有进程/线程要访问的内部数据结构 缓存磁盘上的数据 重做日志(redo log)缓冲  1.1. 后台线程  Master Thread  核心线程，负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性 IO Thread
InnoDB存储引擎大量使用了AIO（Async IO)来处理写IO请求；
InnoDB 1.0版本之前共有4个IO Thread: write, read, insert buffer and log IO thread   查看InnoDB中的 IO Thread:
 show engine innodb status\G 3. Purge Thread
事务被提交后，其所使用的undolog可能不再需要，Purge Thread可以回收已经使用并分配的undo页。
从InnoDB 1.2版本开始，支持多个 Purge Thread, 从而加入undo页的回收；
另外 Purge Thread 离散地读取 undo 页，可以利用磁盘的随机读取性能。
mysql root@127.0.0.1:test&amp;gt; show variables like &amp;#39;innodb_purge_threads&amp;#39; \G ***************************[ 1.'>
<meta property='og:url' content='/p/cp2.-innodb/'>
<meta property='og:site_name' content='Li. Mingzhi'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='algorithm' /><meta property='article:tag' content='recursion' /><meta property='article:published_time' content='2021-03-24T18:36:08&#43;08:00'/><meta property='article:modified_time' content='2021-03-24T18:36:08&#43;08:00'/>
<meta name="twitter:title" content="cp2. InnoDB">
<meta name="twitter:description" content="Statement  这篇文件是我从这本书中的学习笔记: MySQL技术内幕（InnoDB存储引擎）. 非商业用途转载请注明出处，若要更详细了解书中内容，请参考原作。  1. InnoDB体系结构 InnoDB存储引擎有多个内存块组成的一个大的内存池，负责如下工作：
 维护所有进程/线程要访问的内部数据结构 缓存磁盘上的数据 重做日志(redo log)缓冲  1.1. 后台线程  Master Thread  核心线程，负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性 IO Thread
InnoDB存储引擎大量使用了AIO（Async IO)来处理写IO请求；
InnoDB 1.0版本之前共有4个IO Thread: write, read, insert buffer and log IO thread   查看InnoDB中的 IO Thread:
 show engine innodb status\G 3. Purge Thread
事务被提交后，其所使用的undolog可能不再需要，Purge Thread可以回收已经使用并分配的undo页。
从InnoDB 1.2版本开始，支持多个 Purge Thread, 从而加入undo页的回收；
另外 Purge Thread 离散地读取 undo 页，可以利用磁盘的随机读取性能。
mysql root@127.0.0.1:test&amp;gt; show variables like &amp;#39;innodb_purge_threads&amp;#39; \G ***************************[ 1.">
    </head>
    <body class="">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            localStorage.setItem(colorSchemeKey, "auto");
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.body.dataset.scheme = 'dark';
        } else {
            document.body.dataset.scheme = 'light';
        }
    })();
</script><div class="container main-container flex on-phone--column extended article-page with-toolbar">
            <aside class="sidebar left-sidebar sticky">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header class="site-info">
        
            <figure class="site-avatar">
                
                    
                    
                    
                        
                        <img src="/images/avatar_hu518c5ba2d560f0e95b4ebe9ab0244799_30403_300x0_resize_q75_box.jpeg" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                

                
            </figure>
        
        <h1 class="site-name"><a href="">Li. Mingzhi</a></h1>
        <h2 class="site-description">I am a Backend Software Engineer focusing on system design and algorithm(^_^). 
        Progress one percent per day...</h2>
    </header>

    <ol class="menu" id="main-menu">
        
        
        

        <li >
            <a href='/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        

        <li >
            <a href='/p/resume/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>About Me</span>
            </a>
        </li>
        
        

        <li >
            <a href='/archives/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        

        <li >
            <a href='/search/index.html'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        

        
    </ol>
</aside>

            <main class="main full-width">
    <div id="article-toolbar">
        <a href="" class="back-home">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



            <span>Back</span>
        </a>
    </div>

    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/grokking_algorithm/" >
                grokking_algorithm
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/cp2.-innodb/">cp2. InnoDB</a>
    </h2>

    <footer class="article-time">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <time class="article-time--published">Mar 24, 2021</time>
    </footer></div>
</header>

    <section class="article-content">
    <h1 id="statement">Statement</h1>
<ul>
<li>这篇文件是我从这本书中的学习笔记: MySQL技术内幕（InnoDB存储引擎）.</li>
<li>非商业用途转载请注明出处，若要更详细了解书中内容，请参考原作。</li>
</ul>
<h2 id="1-innodb体系结构">1. InnoDB体系结构</h2>
<p>InnoDB存储引擎有多个内存块组成的一个大的内存池，负责如下工作：</p>
<ul>
<li>维护所有进程/线程要访问的内部数据结构</li>
<li>缓存磁盘上的数据</li>
<li>重做日志(redo log)缓冲</li>
</ul>
<h3 id="11-后台线程">1.1. 后台线程</h3>
<ol>
<li>Master Thread</li>
</ol>
<pre><code>核心线程，负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性
</code></pre><ol start="2">
<li>IO Thread<br>
InnoDB存储引擎大量使用了AIO（Async IO)来处理写IO请求；<br>
InnoDB 1.0版本之前共有4个IO Thread: write, read, insert buffer and log IO thread</li>
</ol>
<blockquote>
<p>查看InnoDB中的 IO Thread:</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">show</span> <span class="kp">engine</span> <span class="n">innodb</span> <span class="n">status</span><span class="err">\</span><span class="n">G</span>
</code></pre></div><p><img src="/post/mysql_innodb/images/innodb_io_thread.png" alt="io_thrads"  /><br>
3. Purge Thread<br>
事务被提交后，其所使用的undolog可能不再需要，Purge Thread可以回收已经使用并分配的undo页。<br>
从InnoDB 1.2版本开始，支持多个 Purge Thread, 从而加入undo页的回收；<br>
另外 Purge Thread 离散地读取 undo 页，可以利用磁盘的随机读取性能。</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">mysql</span> <span class="n">root</span><span class="o">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">:</span><span class="n">test</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;innodb_purge_threads&#39;</span> <span class="err">\</span><span class="n">G</span>
<span class="o">***************************</span><span class="p">[</span> <span class="mi">1</span><span class="p">.</span> <span class="n">row</span> <span class="p">]</span><span class="o">***************************</span>
<span class="n">Variable_name</span> <span class="o">|</span> <span class="n">innodb_purge_threads</span>
<span class="n">Value</span>         <span class="o">|</span> <span class="mi">4</span>
</code></pre></div><ol start="4">
<li>Page Cleaner Thread<br>
作用：将之前版本中脏页的刷新操作放到单独的单纯中完成； 其目的是为了减轻原Master Thread的工作，<br>
及对用户查询线程的阻塞，从而提高Innodb存储引擎的性能。</li>
</ol>
<h3 id="12-内存">1.2 内存</h3>
<h4 id="1-缓冲池">1. 缓冲池</h4>
<p>读操作：将从磁盘中读到的页放到缓冲池中，这一过程被称为将页‘FIX’到缓冲池中。<br>
后面再读相同的页时，首先判断该页是否在缓冲池中，若被命中则读取，否则读取磁盘上的页。</p>
<p>写操作：首先修改缓冲池中的页，然后再以一定的频率刷新到磁盘上。<br>
页从缓冲池到磁盘上的刷新操作是通过一种Checkpoint的机制操作的，以提高数据库的整体性能。</p>
<p>查看InnoDB存储引擎的缓冲池大学：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">mysql</span> <span class="n">root</span><span class="o">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">:</span><span class="n">test</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;innodb_buffer_pool_size&#39;</span> <span class="err">\</span><span class="n">G</span>
<span class="o">***************************</span><span class="p">[</span> <span class="mi">1</span><span class="p">.</span> <span class="n">row</span> <span class="p">]</span><span class="o">***************************</span>
<span class="n">Variable_name</span> <span class="o">|</span> <span class="n">innodb_buffer_pool_size</span>
<span class="n">Value</span>         <span class="o">|</span> <span class="mi">134217728</span>

<span class="mi">1</span> <span class="n">row</span> <span class="k">in</span> <span class="kt">set</span>
<span class="kt">Time</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">009</span><span class="n">s</span>
</code></pre></div><p>缓冲池中缓存的数据页类型：</p>
<ul>
<li>索引页</li>
<li>数据页</li>
<li>undo页</li>
<li>插入缓冲(insert buffer)</li>
<li>自适应哈希索引(adaptive hash index)</li>
<li>InnoDB存储的锁信息(lock info)</li>
<li>数据字典信息（data dictionary)</li>
</ul>
<p><img src="/post/mysql_innodb/images/innodb_cache_objects.png" alt="innodb_cache_obj"  /></p>
<p>从 InnoDB 1.0.x开始，可以存在多个缓冲池实例，每个页根据哈希值平均分配到不同的缓冲池实例中，<br>
进而减少了数据库内部的资源竞争，增加其并发处理能力。</p>
<p>我们可以通过 information_schema架构下的表 INNODB_BUFFER_POOL_STATS 来查看缓冲的状态：</p>
<div class="highlight"><pre class="chroma"><code class="language-MySQL" data-lang="MySQL"><span class="n">mysql</span> <span class="n">root</span><span class="o">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">:</span><span class="n">information_schema</span><span class="o">&gt;</span> <span class="k">select</span> <span class="n">POOL_ID</span><span class="p">,</span> <span class="n">POOL_SIZE</span><span class="p">,</span> <span class="n">FREE_BUFFERS</span><span class="p">,</span> <span class="n">DATABASE_PAG</span>
                                         <span class="n">ES</span> <span class="k">from</span> <span class="n">innodb_buffer_pool_stats</span> <span class="err">\</span><span class="n">G</span>
<span class="o">***************************</span><span class="p">[</span> <span class="mi">1</span><span class="p">.</span> <span class="n">row</span> <span class="p">]</span><span class="o">***************************</span>
<span class="n">POOL_ID</span>        <span class="o">|</span> <span class="mi">0</span>
<span class="n">POOL_SIZE</span>      <span class="o">|</span> <span class="mi">8192</span>
<span class="n">FREE_BUFFERS</span>   <span class="o">|</span> <span class="mi">7207</span>
<span class="n">DATABASE_PAGES</span> <span class="o">|</span> <span class="mi">977</span>

<span class="mi">1</span> <span class="n">row</span> <span class="k">in</span> <span class="kt">set</span>
<span class="kt">Time</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">003</span><span class="n">s</span>
</code></pre></div><h4 id="2-lru-list-free-list-和-flush-list">2. LRU List, Free List 和 Flush List</h4>
<p>数据库中的缓冲池一般通过LRU（Latest Recent Used: 最新最近使用)算法来管理的：<br>
最频繁使用的页在LRU列表的前端，当缓冲池不能存放新读取到的页时，将首先释放LRU列表尾端的页。</p>
<p>InnoDB的LRU列表中加入了 midpoint 位置：<br>
新读取的页，并非直接放入LRU列表的首部，而是放到midpoint位置。此算法被称为 midpoint insertion strategy.<br>
该默认位置在LRU列表长度的5/8处。</p>
<p>查看midpoint参数：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">mysql</span> <span class="n">root</span><span class="o">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">:</span><span class="n">information_schema</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;innodb_old_blocks_pct&#39;</span><span class="err">\</span><span class="n">G</span>
<span class="o">***************************</span><span class="p">[</span> <span class="mi">1</span><span class="p">.</span> <span class="n">row</span> <span class="p">]</span><span class="o">***************************</span>
<span class="n">Variable_name</span> <span class="o">|</span> <span class="n">innodb_old_blocks_pct</span>
<span class="n">Value</span>         <span class="o">|</span> <span class="mi">37</span>

<span class="mi">1</span> <span class="n">row</span> <span class="k">in</span> <span class="kt">set</span>
<span class="kt">Time</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">010</span><span class="n">s</span>
</code></pre></div><p>37表示新读取的页插入到LRU列表尾部37%的位置；在InnoDB存储引擎中，把midpoint后面的列表称为old列表，<br>
之前的列表称为new列表。即new列表中的页都是最为活跃的热点数据。</p>
<p>为什么不将读取的页放到LRU列表首部？</p>
<pre><code>若直接将读取的页放到LRU首部，则某些SQL操作会使缓冲池中的页被刷新出，从而影响缓冲池的效率。
如:索引或数据的扫描操作。
若大量的非活跃操作被放入LRU列表的首部，则会把热点数据页从LRU列表中移除，从而导致InnoDB在下一次读取该页时再次访问磁盘。

InnoDB存储引擎引入了 innodb_old_blocks_time， 用于表示页读取到 midpoint 位置后，需要等多久才会被加入到LRU列表的热端，从而尽可能使得LRU列表中的热点数据不被刷出。

若用户预估活跃的热点数据不止63（100－37），可以执行下面的语句来减少热点页被刷出的概率:
</code></pre><blockquote>
<p>SET GLOBAL innodb_old_blocks_pct=20;</p>
</blockquote>
<p>LRU列表创建流程：</p>
<pre><code>1. LRU列表在DB刚启动时是空的，页都存放在Free列表中
2. 当需要从缓冲池中分页时，从Free列表中查找是否有可用的空闲页
3. 若有则将该页从Free列表中删除，放到LRU列表中
4. 否则根据LRU算法，淘汰LRU列表末尾的页，将该内存空间分配给新页
</code></pre><p>当页从LRU列表的old部分加入到new部分时，此时发生的操作被称为 page made young； 而因为innodb_old_blocks_time的设置而导致没有从old部分移动到new部分的操作被称为page not made young。</p>
<p>查看LRU列表及Free列表的状态:</p>
<blockquote>
<p>SHOW ENGINE INNODB STATUS \G</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="o">--------------------</span><span class="c1">--
</span><span class="c1">BUFFER POOL AND MEMORY
</span><span class="c1"></span><span class="o">--------------------</span><span class="c1">--
</span><span class="c1">Total large memory allocated 136970240
</span><span class="c1"></span><span class="n">Dictionary</span> <span class="n">memory</span> <span class="n">allocated</span> <span class="mi">424766</span>
<span class="n">Buffer</span> <span class="n">pool</span> <span class="n">size</span>   <span class="mi">8192</span>
<span class="n">Free</span> <span class="n">buffers</span>       <span class="mi">7208</span>
<span class="k">Database</span> <span class="n">pages</span>     <span class="mi">977</span>
<span class="n">Old</span> <span class="k">database</span> <span class="n">pages</span> <span class="mi">380</span>
<span class="n">Modified</span> <span class="n">db</span> <span class="n">pages</span>  <span class="mi">0</span>
<span class="n">Pending</span> <span class="k">reads</span>      <span class="mi">0</span>
<span class="n">Pending</span> <span class="n">writes</span><span class="p">:</span> <span class="n">LRU</span> <span class="mi">0</span><span class="p">,</span> <span class="k">flush</span> <span class="n">list</span> <span class="mi">0</span><span class="p">,</span> <span class="n">single</span> <span class="n">page</span> <span class="mi">0</span>
<span class="n">Pages</span> <span class="n">made</span> <span class="n">young</span> <span class="mi">0</span><span class="p">,</span> <span class="k">not</span> <span class="n">young</span> <span class="mi">0</span>
<span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">youngs</span><span class="o">/</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">non</span><span class="o">-</span><span class="n">youngs</span><span class="o">/</span><span class="n">s</span>
<span class="n">Pages</span> <span class="k">read</span> <span class="mi">835</span><span class="p">,</span> <span class="n">created</span> <span class="mi">142</span><span class="p">,</span> <span class="n">written</span> <span class="mi">160</span>
<span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="k">reads</span><span class="o">/</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">creates</span><span class="o">/</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">writes</span><span class="o">/</span><span class="n">s</span>
<span class="n">Buffer</span> <span class="n">pool</span> <span class="n">hit</span> <span class="n">rate</span> <span class="mi">1000</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">young</span><span class="o">-</span><span class="n">making</span> <span class="n">rate</span> <span class="mi">0</span> <span class="o">/</span> <span class="mi">1000</span> <span class="k">not</span> <span class="mi">0</span> <span class="o">/</span> <span class="mi">1000</span>
<span class="n">Pages</span> <span class="k">read</span> <span class="n">ahead</span> <span class="mi">0</span><span class="p">.</span><span class="mi">00</span><span class="o">/</span><span class="n">s</span><span class="p">,</span> <span class="n">evicted</span> <span class="n">without</span> <span class="n">access</span> <span class="mi">0</span><span class="p">.</span><span class="mi">00</span><span class="o">/</span><span class="n">s</span><span class="p">,</span> <span class="n">Random</span> <span class="k">read</span> <span class="n">ahead</span> <span class="mi">0</span><span class="p">.</span><span class="mi">00</span><span class="o">/</span><span class="n">s</span>
<span class="n">LRU</span> <span class="n">len</span><span class="p">:</span> <span class="mi">977</span><span class="p">,</span> <span class="n">unzip_LRU</span> <span class="n">len</span><span class="p">:</span> <span class="mi">0</span>
<span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">cur</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">unzip</span> <span class="n">sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">cur</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div><p>当前Buffer pool size共有 8192 个页，即 8192 *16K=128M, 共128MB的缓冲池。<br>
Free buffers 表示当前 Free 列表中页的数量，<br>
Database pages 表示 LRU 列表中页的数量。<br>
Free buffers + Database pages 并不等于 Buffer pool size：<br>
因为缓冲池中的页还可能会被分配给其它页： 自适应哈希索引、 Lock信息、 Insert Buffer等。<br>
这些页不需要LRU算法维护，因此不存在于LRU列表中。</p>
<p>pages made young: LRU列表中页移动到前端的次数<br>
youngs/s, non-youngs/s表示每秒这两人类操作的次数。<br>
Buffer pool hit rate: 缓冲率的命中率，上面例子中为100％，表示缓冲池运行状态良好。通过该值不应小于95%.</p>
<blockquote>
<p>若发生其值小于95％，则需要观察是否是由于全表扫描引起的LRU列表被污染的问题。</p>
</blockquote>
<p>InnoDB从 1.0.x 开始支持压缩页的功能，将原来16KB的页压缩为 1KB、2KB、4KB 和 8KB。<br>
通过 unzip_LRU 列表来管理 非 16KB 的页。但 LRU中的页是包含了 unzip_LRU列表中的页的。</p>
<blockquote>
<p>unzip_LRU如何从缓冲池中分配内存?</p>
</blockquote>
<p>unzip_LRU对不同大小的压缩页的分别管理；<br>
通过伙伴算法进行内存的分配。<br>
例如从缓冲池中申请 4KB 大小的页</p>
<pre><code>1. 检查 4KB 的 unzip_LRU 列表
2. 若有， 则直接使用
3. 否则， 检查 8KB 的 unzip_LRU 列表
4. 若得到空闲页，则将页分布 2 个 4KB 页，存放到 4KB 的 unzip_LRU 列表
5. 否则，从 LRU 列表中申请一个 16KB 的页，将页分为 1 个 8KB、2 个 4KB 的页，分别放到对应的 unzip_LRU 列表中。
</code></pre><blockquote>
<p>脏页(dirty page)</p>
</blockquote>
<pre><code>在LRU列表中的页被修改后，被称为脏页，即缓冲池中的页和磁盘上的页的数据产生了不一致。
DB会通过 Checkpoint 机制将脏页刷新到磁盘；
</code></pre><p>而 Flush 列表中的页为 脏页列表</p>
<blockquote>
<p>LRU 列表管理缓冲池中页的可用性；Flush 列表用来管理将页刷新回磁盘， 二者互不影响。</p>
</blockquote>
<p>上面 INNODB_BUFFER_PAGE_LRU 中的 Modified db pages 显示了脏页的数量。</p>
<h4 id="3-重做日志缓冲redo-log-buffer">3. 重做日志缓冲(redo log buffer)</h4>
<p>InnoDB存储引擎先将重做日志信息放入重做日志缓冲区，再按一定频率将其刷新到重做日志文件。<br>
用户只要保证每秒产生的事务量不超过缓冲区大小即可，因为InnoDB一般会每一秒将重做日志缓冲刷新到日志文件。</p>
<blockquote>
<p>查看重做日志缓冲区大小</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-MySQL" data-lang="MySQL"><span class="n">mysql</span> <span class="n">root</span><span class="o">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">:</span><span class="n">test</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;innodb_log_buffer_size&#39;</span><span class="err">\</span><span class="n">G</span>
<span class="o">***************************</span><span class="p">[</span> <span class="mi">1</span><span class="p">.</span> <span class="n">row</span> <span class="p">]</span><span class="o">***************************</span>
<span class="n">Variable_name</span> <span class="o">|</span> <span class="n">innodb_log_buffer_size</span>
<span class="n">Value</span>         <span class="o">|</span> <span class="mi">16777216</span>

<span class="mi">1</span> <span class="n">row</span> <span class="k">in</span> <span class="kt">set</span>
<span class="kt">Time</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">006</span><span class="n">s</span>
</code></pre></div><p>一般 8～16MB 的重做日志缓冲池足以满足大部分的应用。</p>
<blockquote>
<p>重做日志缓冲刷新到磁盘重做日志的三种情况：</p>
</blockquote>
<ul>
<li>Master Thread 每一秒           将重做日志缓冲刷新到重做日志文件</li>
<li>每个事务提交时会                 将重做日志缓冲刷新到重做日志文件</li>
<li>当重做日志缓冲池剩余空间小于1/2时， 将重做日志缓冲刷新到重做日志文件</li>
</ul>
<h4 id="4-额外的内存池">4. 额外的内存池</h4>
<p>InnoDB通过 内存堆(heap) 对内存进行管理；<br>
在对一些数据结构本身的内存进行分配时，需要从 <!-- raw HTML omitted -->[额外的内存池]<!-- raw HTML omitted --> 中进行申请，<br>
当<!-- raw HTML omitted --> 该区域<!-- raw HTML omitted --> 的内存不够时，会从缓冲池中进行申请。<br>
例如，分配了缓冲池(innodb_buffer_pool)，<br>
每个缓冲池中的<!-- raw HTML omitted -->帧缓冲(frame buffer)<!-- raw HTML omitted -->和对应的 <!-- raw HTML omitted -->缓冲控制对象(buffer control block)<!-- raw HTML omitted -->，<br>
这些对象记录了 LRU， 锁， 等待信息；而这个对象的内存需要从<!-- raw HTML omitted -->[额外内存池]<!-- raw HTML omitted -->中申请。<br>
故在申请了很大的InnoDB缓冲池时，应相应增加该值。</p>
<h2 id="2-checkpoint技术">2 Checkpoint技术</h2>
<p>缓冲池的设计目的是为了协调CPU速度与磁盘速度的鸿沟，因此页的操作是先在缓冲池中完成的。<br>
为了避免宕机导致的缓冲池数据丢失的问题，事务数据库系统采用了 Write Ahead Log 策略：</p>
<blockquote>
<p>当事务提交时，先写重做日志，再修改页。<br>
当数据丢失时，通过重做日志来完成数据所恢复。这就是事务ACID中的D（Durability持久性)的要求。</p>
</blockquote>
<p>Checkpoint的目的是解决以下几个问题：</p>
<ul>
<li>缩短数据库的恢复时间</li>
<li>缓冲池不够用时，将脏页刷新到磁盘</li>
<li>重做日志不可时，刷新脏页</li>
</ul>
<blockquote>
<p>数据库只需对 Checkpoint 后的重做日志进行恢复，这样大缩短了恢复时间。<br>
当缓冲区不够用时，根据LRU算法会溢出最近最少使用的页，若此页为脏页，则强制执行 Checkpoint, 将脏页刷新到磁盘。<br>
重做日志不可用是因为当前事务数据库系统对重做日志的设计是循环使用的，并非无限增长的。</p>
<blockquote>
<p>重做日志可以被重用的部分是指这些日志已经不再需要，若数据库宕机，数据库恢复操盘不需要这部分的重做日志，因此这部分可以被覆盖重用。<br>
若宕机时重做日志还需要使用，则强制产生 Checkpoint, 将缓冲池中的页至少刷新到当前重做日志的位置。</p>
</blockquote>
</blockquote>
<p>InnoDB是通过 LSN(Log Sequence Number)来票房版本的，LSN 是8字节的数字，其单位是字节。<br>
第个页、重做日志、和 Checkpoint 都有 LSN。</p>
<blockquote>
<p>通过命令 SHOW ENGINE INNODB STATUS 查看 LSN：</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-MySQL" data-lang="MySQL"><span class="o">-</span><span class="c1">--
</span><span class="c1">LOG
</span><span class="c1"></span><span class="o">-</span><span class="c1">--
</span><span class="c1">Log sequence number          3723483701
</span><span class="c1"></span><span class="n">Log</span> <span class="n">buffer</span> <span class="n">assigned</span> <span class="n">up</span> <span class="k">to</span>    <span class="mi">3723483701</span>
<span class="n">Log</span> <span class="n">buffer</span> <span class="n">completed</span> <span class="n">up</span> <span class="k">to</span>   <span class="mi">3723483701</span>
<span class="n">Log</span> <span class="n">written</span> <span class="n">up</span> <span class="k">to</span>            <span class="mi">3723483701</span>
<span class="n">Log</span> <span class="n">flushed</span> <span class="n">up</span> <span class="k">to</span>            <span class="mi">3723483701</span>
<span class="n">Added</span> <span class="n">dirty</span> <span class="n">pages</span> <span class="n">up</span> <span class="k">to</span>      <span class="mi">3723483701</span>
<span class="n">Pages</span> <span class="n">flushed</span> <span class="n">up</span> <span class="k">to</span>          <span class="mi">3723483701</span>
<span class="n">Last</span> <span class="n">checkpoint</span> <span class="n">at</span>           <span class="mi">3723483701</span>
<span class="mi">13</span> <span class="n">log</span> <span class="n">i</span><span class="o">/</span><span class="n">o</span><span class="s1">&#39;s done, 0.00 log i/o&#39;</span><span class="n">s</span><span class="o">/</span><span class="n">second</span>
</code></pre></div><blockquote>
<p>两种 Checkpoint:</p>
</blockquote>
<ul>
<li>
<p>Sharp Checkpoint<br>
Sharp Checkpoint是默认的工作方式：在数据库关闭时，将所有的脏页都刷新到磁盘。<br>
参数 innodb_fast_shutdown=1。<br>
但若在数据库运行时使用 Sharp Checkpoint, 会大大影响数据库的可用性。</p>
</li>
<li>
<p>Fuzzy Checkpoint<br>
InnoDB存储引擎内部使用 Fuzzy Checkpoint 进行页的刷新: 只刷新一部分脏页到磁盘。</p>
</li>
</ul>
<blockquote>
<p>InnoDB中的几种 Fuzzy Checkpoint:</p>
</blockquote>
<ul>
<li>Master Thread Checkpoint<br>
以将近每秒或每十秒的速度从缓冲池的脏页列表中刷新一定比例的页到磁盘，此过程是异步的，用户查询线程不会阻塞。</li>
<li>FLUSH_LRU_LIST Checkpoint</li>
</ul>
<pre><code>InnoDB存储引擎需要保证LRU列表中需要有将近100个空闲页可供使用。
在InnoDB 1.1.x版本之前，需要检查 LRU 列表中是否有足够的可用空间操作发生的用户查询线程中，这会阻塞用户的查询操作；
若没有100个可用的空闲页，InnoDB会将 LRU 列表尾端的页移除。
若这些页中有脏页，则需要进行 Checkpoint, 而这些页是来自 LRU列表的，因此称为 FLUSH_LRU_LIST.

在 InnoDB 1.2.x版本开始，该检查被放在了一个单独的 Page Cleaner 线程中进行，
用户可以通过 innodb_lru_scan_depth 控制 LRU列表中可用页的数量，默认值为1024。
</code></pre><ul>
<li>Async/Sync Flush Checkpoint<br>
重做日志不可用时，需要强制将一些页刷新到磁盘，此时脏页是从脏页列表中选取的。<br>
若将已经写入重做日志的LSN记为 redo_lsn, 已经刷新到到磁盘最新页的LSN记录为 checkpoint_lsn, 则：</li>
</ul>
<blockquote>
<blockquote>
<p>checkpoint_age = redo_lsn - checkpoint_lsn</p>
</blockquote>
</blockquote>
<p>再定义以下变量:</p>
<blockquote>
<blockquote>
<p>async_water_mark = 75% * total_redo_log_file_size<br>
sync_water_mark  = 90% * total_redo_log_file_size</p>
</blockquote>
</blockquote>
<pre><code>若每个重做文件的大小为1G，且定义了两个重做日志文件，则重做日志文件的总大小为2GB；
因此 async_water_mark = 1.5GB, sync_water_mark = 1.8GB，则:
1. 若 checkpoint_age &lt; async_water_mark, 不需要刷新脏页到磁盘
2. 若 async_water_mark &lt; checkpoint_age &lt; sync_water_mark, 则触发 Async Flush,
从Flush列表中刷新足够的脏页到磁盘，使用刷新后满足 checkpoint_age &lt; async_water_mark.
3. 若 checkpoint_age &gt; sync_water_mark, 此场景很少发生，除非设置的重做日志文件太小，且在进行 LOAD DATA 的 BULK INSERT 操作。此时触发 Sync Flush操作，使用刷新后满足 checkpoint_age &lt; async_water_mark。

从InnoDB 1.2.x版本开始， 这部分刷新操作也放到了单独的 Page Cleaner Thread中，故不会阻塞查询线程。
</code></pre><ul>
<li>Dirty Page too much Checkpoint<br>
脏页的数量太多导致Checkpoint，保证缓冲池中有足够可用的页。<br>
控制参数：innodb_max_dirty_pages_pct</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-MySQL" data-lang="MySQL"><span class="n">mysql</span> <span class="n">root</span><span class="o">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">:</span><span class="n">test</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;innodb_max_dirty_pages_pct&#39;</span><span class="err">\</span><span class="n">G</span>
<span class="o">***************************</span><span class="p">[</span> <span class="mi">1</span><span class="p">.</span> <span class="n">row</span> <span class="p">]</span><span class="o">***************************</span>
<span class="n">Variable_name</span> <span class="o">|</span> <span class="n">innodb_max_dirty_pages_pct</span>
<span class="n">Value</span>         <span class="o">|</span> <span class="mi">90</span><span class="p">.</span><span class="mi">000000</span>

<span class="mi">1</span> <span class="n">row</span> <span class="k">in</span> <span class="kt">set</span>
<span class="kt">Time</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">010</span><span class="n">s</span>
</code></pre></div><p>Value为90表示：当缓冲池中脏页的数量占据90%时，强制进行 Checkpoint, 刷新部分脏页到磁盘。</p>
<h2 id="3-master-thread-工作方式">3. Master Thread 工作方式</h2>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/algorithm/">algorithm</a>
        
            <a href="/tags/recursion/">recursion</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>

    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/p/ga-3.-recursion/">
        
        

        <div class="article-details">
            <h2 class="article-title">GA: 3. Recursion</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/ga-7.-dijkstras-algorithm/">
        
        

        <div class="article-details">
            <h2 class="article-title">GA: 7. Dijkstra&#39;s algorithm</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/ga-6.-breadth-first-search/">
        
        

        <div class="article-details">
            <h2 class="article-title">GA: 6. Breadth-first search</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/ga-5.-hash-tables/">
        
        

        <div class="article-details">
            <h2 class="article-title">GA: 5. Hash tables</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/ga-4.-quicksort/">
        
        

        <div class="article-details">
            <h2 class="article-title">GA: 4. Quicksort</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>


    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2021 Li. Mingzhi
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="2.2.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >
            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
