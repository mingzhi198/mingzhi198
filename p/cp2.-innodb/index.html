<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='Statement  这篇文件是我从这本书中的学习笔记: MySQL技术内幕（InnoDB存储引擎）. 非商业用途转载请注明出处，若要更详细了解书中内容，请参考原作。  1. InnoDB体系结构 InnoDB存储引擎有多个内存块组成的一个大的内存池，负责如下工作：
 维护所有进程/线程要访问的内部数据结构 缓存磁盘上的数据 重做日志(redo log)缓冲  1.1. 后台线程  Master Thread  核心线程，负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性 IO Thread
InnoDB存储引擎大量使用了AIO（Async IO)来处理写IO请求；
InnoDB 1.0版本之前共有4个IO Thread: write, read, insert buffer and log IO thread   查看InnoDB中的 IO Thread:
 show engine innodb status\G 3. Purge Thread
事务被提交后，其所使用的undolog可能不再需要，Purge Thread可以回收已经使用并分配的undo页。
从InnoDB 1.2版本开始，支持多个 Purge Thread, 从而加入undo页的回收；
另外 Purge Thread 离散地读取 undo 页，可以利用磁盘的随机读取性能。
mysql root@127.0.0.1:test&amp;gt; show variables like &amp;#39;innodb_purge_threads&amp;#39; \G ***************************[ 1.'><title>cp2. InnoDB</title>

<link rel='canonical' href='/p/cp2.-innodb/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='cp2. InnoDB'>
<meta property='og:description' content='Statement  这篇文件是我从这本书中的学习笔记: MySQL技术内幕（InnoDB存储引擎）. 非商业用途转载请注明出处，若要更详细了解书中内容，请参考原作。  1. InnoDB体系结构 InnoDB存储引擎有多个内存块组成的一个大的内存池，负责如下工作：
 维护所有进程/线程要访问的内部数据结构 缓存磁盘上的数据 重做日志(redo log)缓冲  1.1. 后台线程  Master Thread  核心线程，负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性 IO Thread
InnoDB存储引擎大量使用了AIO（Async IO)来处理写IO请求；
InnoDB 1.0版本之前共有4个IO Thread: write, read, insert buffer and log IO thread   查看InnoDB中的 IO Thread:
 show engine innodb status\G 3. Purge Thread
事务被提交后，其所使用的undolog可能不再需要，Purge Thread可以回收已经使用并分配的undo页。
从InnoDB 1.2版本开始，支持多个 Purge Thread, 从而加入undo页的回收；
另外 Purge Thread 离散地读取 undo 页，可以利用磁盘的随机读取性能。
mysql root@127.0.0.1:test&amp;gt; show variables like &amp;#39;innodb_purge_threads&amp;#39; \G ***************************[ 1.'>
<meta property='og:url' content='/p/cp2.-innodb/'>
<meta property='og:site_name' content='Li. Mingzhi'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='MySQL' /><meta property='article:tag' content='InnoDB' /><meta property='article:published_time' content='2021-03-24T18:36:08&#43;08:00'/><meta property='article:modified_time' content='2021-03-24T18:36:08&#43;08:00'/>
<meta name="twitter:title" content="cp2. InnoDB">
<meta name="twitter:description" content="Statement  这篇文件是我从这本书中的学习笔记: MySQL技术内幕（InnoDB存储引擎）. 非商业用途转载请注明出处，若要更详细了解书中内容，请参考原作。  1. InnoDB体系结构 InnoDB存储引擎有多个内存块组成的一个大的内存池，负责如下工作：
 维护所有进程/线程要访问的内部数据结构 缓存磁盘上的数据 重做日志(redo log)缓冲  1.1. 后台线程  Master Thread  核心线程，负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性 IO Thread
InnoDB存储引擎大量使用了AIO（Async IO)来处理写IO请求；
InnoDB 1.0版本之前共有4个IO Thread: write, read, insert buffer and log IO thread   查看InnoDB中的 IO Thread:
 show engine innodb status\G 3. Purge Thread
事务被提交后，其所使用的undolog可能不再需要，Purge Thread可以回收已经使用并分配的undo页。
从InnoDB 1.2版本开始，支持多个 Purge Thread, 从而加入undo页的回收；
另外 Purge Thread 离散地读取 undo 页，可以利用磁盘的随机读取性能。
mysql root@127.0.0.1:test&amp;gt; show variables like &amp;#39;innodb_purge_threads&amp;#39; \G ***************************[ 1.">
    </head>
    <body class="">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            localStorage.setItem(colorSchemeKey, "auto");
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.body.dataset.scheme = 'dark';
        } else {
            document.body.dataset.scheme = 'light';
        }
    })();
</script><div class="container main-container flex on-phone--column extended article-page with-toolbar">
            <aside class="sidebar left-sidebar sticky">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header class="site-info">
        
            <figure class="site-avatar">
                
                    
                    
                    
                        
                        <img src="/images/avatar_hu518c5ba2d560f0e95b4ebe9ab0244799_30403_300x0_resize_q75_box.jpeg" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                

                
            </figure>
        
        <h1 class="site-name"><a href="">Li. Mingzhi</a></h1>
        <h2 class="site-description">I am a Backend Software Engineer focusing on system design and algorithm(^_^). 
        Progress one percent per day...</h2>
    </header>

    <ol class="menu" id="main-menu">
        
        
        

        <li >
            <a href='/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        

        <li >
            <a href='/p/resume/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>About Me</span>
            </a>
        </li>
        
        

        <li >
            <a href='/archives/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        

        <li >
            <a href='/search/index.html'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        

        
    </ol>
</aside>

            <main class="main full-width">
    <div id="article-toolbar">
        <a href="" class="back-home">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



            <span>Back</span>
        </a>
    </div>

    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/" >
                MySQL技术内幕
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/cp2.-innodb/">cp2. InnoDB</a>
    </h2>

    <footer class="article-time">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <time class="article-time--published">Mar 24, 2021</time>
    </footer></div>
</header>

    <section class="article-content">
    <h1 id="statement">Statement</h1>
<ul>
<li>这篇文件是我从这本书中的学习笔记: MySQL技术内幕（InnoDB存储引擎）.</li>
<li>非商业用途转载请注明出处，若要更详细了解书中内容，请参考原作。</li>
</ul>
<h2 id="1-innodb体系结构">1. InnoDB体系结构</h2>
<p>InnoDB存储引擎有多个内存块组成的一个大的内存池，负责如下工作：</p>
<ul>
<li>维护所有进程/线程要访问的内部数据结构</li>
<li>缓存磁盘上的数据</li>
<li>重做日志(redo log)缓冲</li>
</ul>
<h3 id="11-后台线程">1.1. 后台线程</h3>
<ol>
<li>Master Thread</li>
</ol>
<pre><code>核心线程，负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性
</code></pre><ol start="2">
<li>IO Thread<br>
InnoDB存储引擎大量使用了AIO（Async IO)来处理写IO请求；<br>
InnoDB 1.0版本之前共有4个IO Thread: write, read, insert buffer and log IO thread</li>
</ol>
<blockquote>
<p>查看InnoDB中的 IO Thread:</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">show</span> <span class="kp">engine</span> <span class="n">innodb</span> <span class="n">status</span><span class="err">\</span><span class="n">G</span>
</code></pre></div><p><img src="/post/mysql_innodb/images/innodb_io_thread.png" alt="io_thrads"  /><br>
3. Purge Thread<br>
事务被提交后，其所使用的undolog可能不再需要，Purge Thread可以回收已经使用并分配的undo页。<br>
从InnoDB 1.2版本开始，支持多个 Purge Thread, 从而加入undo页的回收；<br>
另外 Purge Thread 离散地读取 undo 页，可以利用磁盘的随机读取性能。</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">mysql</span> <span class="n">root</span><span class="o">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">:</span><span class="n">test</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;innodb_purge_threads&#39;</span> <span class="err">\</span><span class="n">G</span>
<span class="o">***************************</span><span class="p">[</span> <span class="mi">1</span><span class="p">.</span> <span class="n">row</span> <span class="p">]</span><span class="o">***************************</span>
<span class="n">Variable_name</span> <span class="o">|</span> <span class="n">innodb_purge_threads</span>
<span class="n">Value</span>         <span class="o">|</span> <span class="mi">4</span>
</code></pre></div><ol start="4">
<li>Page Cleaner Thread<br>
作用：将之前版本中脏页的刷新操作放到单独的单纯中完成； 其目的是为了减轻原Master Thread的工作，<br>
及对用户查询线程的阻塞，从而提高Innodb存储引擎的性能。</li>
</ol>
<h3 id="12-内存">1.2 内存</h3>
<h4 id="1-缓冲池">1. 缓冲池</h4>
<p>读操作：将从磁盘中读到的页放到缓冲池中，这一过程被称为将页‘FIX’到缓冲池中。<br>
后面再读相同的页时，首先判断该页是否在缓冲池中，若被命中则读取，否则读取磁盘上的页。</p>
<p>写操作：首先修改缓冲池中的页，然后再以一定的频率刷新到磁盘上。<br>
页从缓冲池到磁盘上的刷新操作是通过一种Checkpoint的机制操作的，以提高数据库的整体性能。</p>
<p>查看InnoDB存储引擎的缓冲池大学：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">mysql</span> <span class="n">root</span><span class="o">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">:</span><span class="n">test</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;innodb_buffer_pool_size&#39;</span> <span class="err">\</span><span class="n">G</span>
<span class="o">***************************</span><span class="p">[</span> <span class="mi">1</span><span class="p">.</span> <span class="n">row</span> <span class="p">]</span><span class="o">***************************</span>
<span class="n">Variable_name</span> <span class="o">|</span> <span class="n">innodb_buffer_pool_size</span>
<span class="n">Value</span>         <span class="o">|</span> <span class="mi">134217728</span>

<span class="mi">1</span> <span class="n">row</span> <span class="k">in</span> <span class="kt">set</span>
<span class="kt">Time</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">009</span><span class="n">s</span>
</code></pre></div><p>缓冲池中缓存的数据页类型：</p>
<ul>
<li>索引页</li>
<li>数据页</li>
<li>undo页</li>
<li>插入缓冲(insert buffer)</li>
<li>自适应哈希索引(adaptive hash index)</li>
<li>InnoDB存储的锁信息(lock info)</li>
<li>数据字典信息（data dictionary)</li>
</ul>
<p><img src="/post/mysql_innodb/images/innodb_cache_objects.png" alt="innodb_cache_obj"  /></p>
<p>从 InnoDB 1.0.x开始，可以存在多个缓冲池实例，每个页根据哈希值平均分配到不同的缓冲池实例中，<br>
进而减少了数据库内部的资源竞争，增加其并发处理能力。</p>
<p>我们可以通过 information_schema架构下的表 INNODB_BUFFER_POOL_STATS 来查看缓冲的状态：</p>
<div class="highlight"><pre class="chroma"><code class="language-MySQL" data-lang="MySQL"><span class="n">mysql</span> <span class="n">root</span><span class="o">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">:</span><span class="n">information_schema</span><span class="o">&gt;</span> <span class="k">select</span> <span class="n">POOL_ID</span><span class="p">,</span> <span class="n">POOL_SIZE</span><span class="p">,</span> <span class="n">FREE_BUFFERS</span><span class="p">,</span> <span class="n">DATABASE_PAG</span>
                                         <span class="n">ES</span> <span class="k">from</span> <span class="n">innodb_buffer_pool_stats</span> <span class="err">\</span><span class="n">G</span>
<span class="o">***************************</span><span class="p">[</span> <span class="mi">1</span><span class="p">.</span> <span class="n">row</span> <span class="p">]</span><span class="o">***************************</span>
<span class="n">POOL_ID</span>        <span class="o">|</span> <span class="mi">0</span>
<span class="n">POOL_SIZE</span>      <span class="o">|</span> <span class="mi">8192</span>
<span class="n">FREE_BUFFERS</span>   <span class="o">|</span> <span class="mi">7207</span>
<span class="n">DATABASE_PAGES</span> <span class="o">|</span> <span class="mi">977</span>

<span class="mi">1</span> <span class="n">row</span> <span class="k">in</span> <span class="kt">set</span>
<span class="kt">Time</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">003</span><span class="n">s</span>
</code></pre></div><h4 id="2-lru-list-free-list-和-flush-list">2. LRU List, Free List 和 Flush List</h4>
<p>数据库中的缓冲池一般通过LRU（Latest Recent Used: 最新最近使用)算法来管理的：<br>
最频繁使用的页在LRU列表的前端，当缓冲池不能存放新读取到的页时，将首先释放LRU列表尾端的页。</p>
<p>InnoDB的LRU列表中加入了 midpoint 位置：<br>
新读取的页，并非直接放入LRU列表的首部，而是放到midpoint位置。此算法被称为 midpoint insertion strategy.<br>
该默认位置在LRU列表长度的5/8处。</p>
<p>查看midpoint参数：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">mysql</span> <span class="n">root</span><span class="o">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">:</span><span class="n">information_schema</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;innodb_old_blocks_pct&#39;</span><span class="err">\</span><span class="n">G</span>
<span class="o">***************************</span><span class="p">[</span> <span class="mi">1</span><span class="p">.</span> <span class="n">row</span> <span class="p">]</span><span class="o">***************************</span>
<span class="n">Variable_name</span> <span class="o">|</span> <span class="n">innodb_old_blocks_pct</span>
<span class="n">Value</span>         <span class="o">|</span> <span class="mi">37</span>

<span class="mi">1</span> <span class="n">row</span> <span class="k">in</span> <span class="kt">set</span>
<span class="kt">Time</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">010</span><span class="n">s</span>
</code></pre></div><p>37表示新读取的页插入到LRU列表尾部37%的位置；在InnoDB存储引擎中，把midpoint后面的列表称为old列表，<br>
之前的列表称为new列表。即new列表中的页都是最为活跃的热点数据。</p>
<p>为什么不将读取的页放到LRU列表首部？</p>
<pre><code>若直接将读取的页放到LRU首部，则某些SQL操作会使缓冲池中的页被刷新出，从而影响缓冲池的效率。
如:索引或数据的扫描操作。
若大量的非活跃操作被放入LRU列表的首部，则会把热点数据页从LRU列表中移除，从而导致InnoDB在下一次读取该页时再次访问磁盘。

InnoDB存储引擎引入了 innodb_old_blocks_time， 用于表示页读取到 midpoint 位置后，需要等多久才会被加入到LRU列表的热端，从而尽可能使得LRU列表中的热点数据不被刷出。

若用户预估活跃的热点数据不止63（100－37），可以执行下面的语句来减少热点页被刷出的概率:
</code></pre><blockquote>
<p>SET GLOBAL innodb_old_blocks_pct=20;</p>
</blockquote>
<p>LRU列表创建流程：</p>
<pre><code>1. LRU列表在DB刚启动时是空的，页都存放在Free列表中
2. 当需要从缓冲池中分页时，从Free列表中查找是否有可用的空闲页
3. 若有则将该页从Free列表中删除，放到LRU列表中
4. 否则根据LRU算法，淘汰LRU列表末尾的页，将该内存空间分配给新页
</code></pre><p>当页从LRU列表的old部分加入到new部分时，此时发生的操作被称为 page made young； 而因为innodb_old_blocks_time的设置而导致没有从old部分移动到new部分的操作被称为page not made young。</p>
<p>查看LRU列表及Free列表的状态:</p>
<blockquote>
<p>SHOW ENGINE INNODB STATUS \G</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="o">--------------------</span><span class="c1">--
</span><span class="c1">BUFFER POOL AND MEMORY
</span><span class="c1"></span><span class="o">--------------------</span><span class="c1">--
</span><span class="c1">Total large memory allocated 136970240
</span><span class="c1"></span><span class="n">Dictionary</span> <span class="n">memory</span> <span class="n">allocated</span> <span class="mi">424766</span>
<span class="n">Buffer</span> <span class="n">pool</span> <span class="n">size</span>   <span class="mi">8192</span>
<span class="n">Free</span> <span class="n">buffers</span>       <span class="mi">7208</span>
<span class="k">Database</span> <span class="n">pages</span>     <span class="mi">977</span>
<span class="n">Old</span> <span class="k">database</span> <span class="n">pages</span> <span class="mi">380</span>
<span class="n">Modified</span> <span class="n">db</span> <span class="n">pages</span>  <span class="mi">0</span>
<span class="n">Pending</span> <span class="k">reads</span>      <span class="mi">0</span>
<span class="n">Pending</span> <span class="n">writes</span><span class="p">:</span> <span class="n">LRU</span> <span class="mi">0</span><span class="p">,</span> <span class="k">flush</span> <span class="n">list</span> <span class="mi">0</span><span class="p">,</span> <span class="n">single</span> <span class="n">page</span> <span class="mi">0</span>
<span class="n">Pages</span> <span class="n">made</span> <span class="n">young</span> <span class="mi">0</span><span class="p">,</span> <span class="k">not</span> <span class="n">young</span> <span class="mi">0</span>
<span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">youngs</span><span class="o">/</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">non</span><span class="o">-</span><span class="n">youngs</span><span class="o">/</span><span class="n">s</span>
<span class="n">Pages</span> <span class="k">read</span> <span class="mi">835</span><span class="p">,</span> <span class="n">created</span> <span class="mi">142</span><span class="p">,</span> <span class="n">written</span> <span class="mi">160</span>
<span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="k">reads</span><span class="o">/</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">creates</span><span class="o">/</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">writes</span><span class="o">/</span><span class="n">s</span>
<span class="n">Buffer</span> <span class="n">pool</span> <span class="n">hit</span> <span class="n">rate</span> <span class="mi">1000</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">young</span><span class="o">-</span><span class="n">making</span> <span class="n">rate</span> <span class="mi">0</span> <span class="o">/</span> <span class="mi">1000</span> <span class="k">not</span> <span class="mi">0</span> <span class="o">/</span> <span class="mi">1000</span>
<span class="n">Pages</span> <span class="k">read</span> <span class="n">ahead</span> <span class="mi">0</span><span class="p">.</span><span class="mi">00</span><span class="o">/</span><span class="n">s</span><span class="p">,</span> <span class="n">evicted</span> <span class="n">without</span> <span class="n">access</span> <span class="mi">0</span><span class="p">.</span><span class="mi">00</span><span class="o">/</span><span class="n">s</span><span class="p">,</span> <span class="n">Random</span> <span class="k">read</span> <span class="n">ahead</span> <span class="mi">0</span><span class="p">.</span><span class="mi">00</span><span class="o">/</span><span class="n">s</span>
<span class="n">LRU</span> <span class="n">len</span><span class="p">:</span> <span class="mi">977</span><span class="p">,</span> <span class="n">unzip_LRU</span> <span class="n">len</span><span class="p">:</span> <span class="mi">0</span>
<span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">cur</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">unzip</span> <span class="n">sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">cur</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div><p>当前Buffer pool size共有 8192 个页，即 8192 *16K=128M, 共128MB的缓冲池。<br>
Free buffers 表示当前 Free 列表中页的数量，<br>
Database pages 表示 LRU 列表中页的数量。<br>
Free buffers + Database pages 并不等于 Buffer pool size：<br>
因为缓冲池中的页还可能会被分配给其它页： 自适应哈希索引、 Lock信息、 Insert Buffer等。<br>
这些页不需要LRU算法维护，因此不存在于LRU列表中。</p>
<p>pages made young: LRU列表中页移动到前端的次数<br>
youngs/s, non-youngs/s表示每秒这两人类操作的次数。<br>
Buffer pool hit rate: 缓冲率的命中率，上面例子中为100％，表示缓冲池运行状态良好。通过该值不应小于95%.</p>
<blockquote>
<p>若发生其值小于95％，则需要观察是否是由于全表扫描引起的LRU列表被污染的问题。</p>
</blockquote>
<p>InnoDB从 1.0.x 开始支持压缩页的功能，将原来16KB的页压缩为 1KB、2KB、4KB 和 8KB。<br>
通过 unzip_LRU 列表来管理 非 16KB 的页。但 LRU中的页是包含了 unzip_LRU列表中的页的。</p>
<blockquote>
<p>unzip_LRU如何从缓冲池中分配内存?</p>
</blockquote>
<p>unzip_LRU对不同大小的压缩页的分别管理；<br>
通过伙伴算法进行内存的分配。<br>
例如从缓冲池中申请 4KB 大小的页</p>
<pre><code>1. 检查 4KB 的 unzip_LRU 列表
2. 若有， 则直接使用
3. 否则， 检查 8KB 的 unzip_LRU 列表
4. 若得到空闲页，则将页分布 2 个 4KB 页，存放到 4KB 的 unzip_LRU 列表
5. 否则，从 LRU 列表中申请一个 16KB 的页，将页分为 1 个 8KB、2 个 4KB 的页，分别放到对应的 unzip_LRU 列表中。
</code></pre><blockquote>
<p>脏页(dirty page)</p>
</blockquote>
<pre><code>在LRU列表中的页被修改后，被称为脏页，即缓冲池中的页和磁盘上的页的数据产生了不一致。
DB会通过 Checkpoint 机制将脏页刷新到磁盘；
</code></pre><p>而 Flush 列表中的页为 脏页列表</p>
<blockquote>
<p>LRU 列表管理缓冲池中页的可用性；Flush 列表用来管理将页刷新回磁盘， 二者互不影响。</p>
</blockquote>
<p>上面 INNODB_BUFFER_PAGE_LRU 中的 Modified db pages 显示了脏页的数量。</p>
<h4 id="3-重做日志缓冲redo-log-buffer">3. 重做日志缓冲(redo log buffer)</h4>
<p>InnoDB存储引擎先将重做日志信息放入重做日志缓冲区，再按一定频率将其刷新到重做日志文件。<br>
用户只要保证每秒产生的事务量不超过缓冲区大小即可，因为InnoDB一般会每一秒将重做日志缓冲刷新到日志文件。</p>
<blockquote>
<p>查看重做日志缓冲区大小</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-MySQL" data-lang="MySQL"><span class="n">mysql</span> <span class="n">root</span><span class="o">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">:</span><span class="n">test</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;innodb_log_buffer_size&#39;</span><span class="err">\</span><span class="n">G</span>
<span class="o">***************************</span><span class="p">[</span> <span class="mi">1</span><span class="p">.</span> <span class="n">row</span> <span class="p">]</span><span class="o">***************************</span>
<span class="n">Variable_name</span> <span class="o">|</span> <span class="n">innodb_log_buffer_size</span>
<span class="n">Value</span>         <span class="o">|</span> <span class="mi">16777216</span>

<span class="mi">1</span> <span class="n">row</span> <span class="k">in</span> <span class="kt">set</span>
<span class="kt">Time</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">006</span><span class="n">s</span>
</code></pre></div><p>一般 8～16MB 的重做日志缓冲池足以满足大部分的应用。</p>
<blockquote>
<p>重做日志缓冲刷新到磁盘重做日志的三种情况：</p>
</blockquote>
<ul>
<li>Master Thread 每一秒           将重做日志缓冲刷新到重做日志文件</li>
<li>每个事务提交时会                 将重做日志缓冲刷新到重做日志文件</li>
<li>当重做日志缓冲池剩余空间小于1/2时， 将重做日志缓冲刷新到重做日志文件</li>
</ul>
<h4 id="4-额外的内存池">4. 额外的内存池</h4>
<p>InnoDB通过 内存堆(heap) 对内存进行管理；<br>
在对一些数据结构本身的内存进行分配时，需要从 <!-- raw HTML omitted -->[额外的内存池]<!-- raw HTML omitted --> 中进行申请，<br>
当<!-- raw HTML omitted --> 该区域<!-- raw HTML omitted --> 的内存不够时，会从缓冲池中进行申请。<br>
例如，分配了缓冲池(innodb_buffer_pool)，<br>
每个缓冲池中的<!-- raw HTML omitted -->帧缓冲(frame buffer)<!-- raw HTML omitted -->和对应的 <!-- raw HTML omitted -->缓冲控制对象(buffer control block)<!-- raw HTML omitted -->，<br>
这些对象记录了 LRU， 锁， 等待信息；而这个对象的内存需要从<!-- raw HTML omitted -->[额外内存池]<!-- raw HTML omitted -->中申请。<br>
故在申请了很大的InnoDB缓冲池时，应相应增加该值。</p>
<h2 id="2-checkpoint技术">2 Checkpoint技术</h2>
<p>缓冲池的设计目的是为了协调CPU速度与磁盘速度的鸿沟，因此页的操作是先在缓冲池中完成的。<br>
为了避免宕机导致的缓冲池数据丢失的问题，事务数据库系统采用了 Write Ahead Log 策略：</p>
<blockquote>
<p>当事务提交时，先写重做日志，再修改页。<br>
当数据丢失时，通过重做日志来完成数据所恢复。这就是事务ACID中的D（Durability持久性)的要求。</p>
</blockquote>
<p>Checkpoint的目的是解决以下几个问题：</p>
<ul>
<li>缩短数据库的恢复时间</li>
<li>缓冲池不够用时，将脏页刷新到磁盘</li>
<li>重做日志不可时，刷新脏页</li>
</ul>
<blockquote>
<p>数据库只需对 Checkpoint 后的重做日志进行恢复，这样大缩短了恢复时间。<br>
当缓冲区不够用时，根据LRU算法会溢出最近最少使用的页，若此页为脏页，则强制执行 Checkpoint, 将脏页刷新到磁盘。<br>
重做日志不可用是因为当前事务数据库系统对重做日志的设计是循环使用的，并非无限增长的。</p>
<blockquote>
<p>重做日志可以被重用的部分是指这些日志已经不再需要，若数据库宕机，数据库恢复操盘不需要这部分的重做日志，因此这部分可以被覆盖重用。<br>
若宕机时重做日志还需要使用，则强制产生 Checkpoint, 将缓冲池中的页至少刷新到当前重做日志的位置。</p>
</blockquote>
</blockquote>
<p>InnoDB是通过 LSN(Log Sequence Number)来票房版本的，LSN 是8字节的数字，其单位是字节。<br>
第个页、重做日志、和 Checkpoint 都有 LSN。</p>
<blockquote>
<p>通过命令 SHOW ENGINE INNODB STATUS 查看 LSN：</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-MySQL" data-lang="MySQL"><span class="o">-</span><span class="c1">--
</span><span class="c1">LOG
</span><span class="c1"></span><span class="o">-</span><span class="c1">--
</span><span class="c1">Log sequence number          3723483701
</span><span class="c1"></span><span class="n">Log</span> <span class="n">buffer</span> <span class="n">assigned</span> <span class="n">up</span> <span class="k">to</span>    <span class="mi">3723483701</span>
<span class="n">Log</span> <span class="n">buffer</span> <span class="n">completed</span> <span class="n">up</span> <span class="k">to</span>   <span class="mi">3723483701</span>
<span class="n">Log</span> <span class="n">written</span> <span class="n">up</span> <span class="k">to</span>            <span class="mi">3723483701</span>
<span class="n">Log</span> <span class="n">flushed</span> <span class="n">up</span> <span class="k">to</span>            <span class="mi">3723483701</span>
<span class="n">Added</span> <span class="n">dirty</span> <span class="n">pages</span> <span class="n">up</span> <span class="k">to</span>      <span class="mi">3723483701</span>
<span class="n">Pages</span> <span class="n">flushed</span> <span class="n">up</span> <span class="k">to</span>          <span class="mi">3723483701</span>
<span class="n">Last</span> <span class="n">checkpoint</span> <span class="n">at</span>           <span class="mi">3723483701</span>
<span class="mi">13</span> <span class="n">log</span> <span class="n">i</span><span class="o">/</span><span class="n">o</span><span class="s1">&#39;s done, 0.00 log i/o&#39;</span><span class="n">s</span><span class="o">/</span><span class="n">second</span>
</code></pre></div><blockquote>
<p>两种 Checkpoint:</p>
</blockquote>
<ul>
<li>
<p>Sharp Checkpoint<br>
Sharp Checkpoint是默认的工作方式：在数据库关闭时，将所有的脏页都刷新到磁盘。<br>
参数 innodb_fast_shutdown=1。<br>
但若在数据库运行时使用 Sharp Checkpoint, 会大大影响数据库的可用性。</p>
</li>
<li>
<p>Fuzzy Checkpoint<br>
InnoDB存储引擎内部使用 Fuzzy Checkpoint 进行页的刷新: 只刷新一部分脏页到磁盘。</p>
</li>
</ul>
<blockquote>
<p>InnoDB中的几种 Fuzzy Checkpoint:</p>
</blockquote>
<ul>
<li>Master Thread Checkpoint<br>
以将近每秒或每十秒的速度从缓冲池的脏页列表中刷新一定比例的页到磁盘，此过程是异步的，用户查询线程不会阻塞。</li>
<li>FLUSH_LRU_LIST Checkpoint</li>
</ul>
<pre><code>InnoDB存储引擎需要保证LRU列表中需要有将近100个空闲页可供使用。
在InnoDB 1.1.x版本之前，需要检查 LRU 列表中是否有足够的可用空间操作发生的用户查询线程中，这会阻塞用户的查询操作；
若没有100个可用的空闲页，InnoDB会将 LRU 列表尾端的页移除。
若这些页中有脏页，则需要进行 Checkpoint, 而这些页是来自 LRU列表的，因此称为 FLUSH_LRU_LIST.

在 InnoDB 1.2.x版本开始，该检查被放在了一个单独的 Page Cleaner 线程中进行，
用户可以通过 innodb_lru_scan_depth 控制 LRU列表中可用页的数量，默认值为1024。
</code></pre><ul>
<li>Async/Sync Flush Checkpoint<br>
重做日志不可用时，需要强制将一些页刷新到磁盘，此时脏页是从脏页列表中选取的。<br>
若将已经写入重做日志的LSN记为 redo_lsn, 已经刷新到到磁盘最新页的LSN记录为 checkpoint_lsn, 则：</li>
</ul>
<blockquote>
<blockquote>
<p>checkpoint_age = redo_lsn - checkpoint_lsn</p>
</blockquote>
</blockquote>
<p>再定义以下变量:</p>
<blockquote>
<blockquote>
<p>async_water_mark = 75% * total_redo_log_file_size<br>
sync_water_mark  = 90% * total_redo_log_file_size</p>
</blockquote>
</blockquote>
<pre><code>若每个重做文件的大小为1G，且定义了两个重做日志文件，则重做日志文件的总大小为2GB；
因此 async_water_mark = 1.5GB, sync_water_mark = 1.8GB，则:
1. 若 checkpoint_age &lt; async_water_mark, 不需要刷新脏页到磁盘
2. 若 async_water_mark &lt; checkpoint_age &lt; sync_water_mark, 则触发 Async Flush,
从Flush列表中刷新足够的脏页到磁盘，使用刷新后满足 checkpoint_age &lt; async_water_mark.
3. 若 checkpoint_age &gt; sync_water_mark, 此场景很少发生，除非设置的重做日志文件太小，且在进行 LOAD DATA 的 BULK INSERT 操作。此时触发 Sync Flush操作，使用刷新后满足 checkpoint_age &lt; async_water_mark。

从InnoDB 1.2.x版本开始， 这部分刷新操作也放到了单独的 Page Cleaner Thread中，故不会阻塞查询线程。
</code></pre><ul>
<li>Dirty Page too much Checkpoint<br>
脏页的数量太多导致Checkpoint，保证缓冲池中有足够可用的页。<br>
控制参数：innodb_max_dirty_pages_pct</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-MySQL" data-lang="MySQL"><span class="n">mysql</span> <span class="n">root</span><span class="o">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">:</span><span class="n">test</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;innodb_max_dirty_pages_pct&#39;</span><span class="err">\</span><span class="n">G</span>
<span class="o">***************************</span><span class="p">[</span> <span class="mi">1</span><span class="p">.</span> <span class="n">row</span> <span class="p">]</span><span class="o">***************************</span>
<span class="n">Variable_name</span> <span class="o">|</span> <span class="n">innodb_max_dirty_pages_pct</span>
<span class="n">Value</span>         <span class="o">|</span> <span class="mi">90</span><span class="p">.</span><span class="mi">000000</span>

<span class="mi">1</span> <span class="n">row</span> <span class="k">in</span> <span class="kt">set</span>
<span class="kt">Time</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">010</span><span class="n">s</span>
</code></pre></div><p>Value为90表示：当缓冲池中脏页的数量占据90%时，强制进行 Checkpoint, 刷新部分脏页到磁盘。</p>
<h2 id="3-master-thread-工作方式">3. Master Thread 工作方式</h2>
<p>ＩnnoDB存储引擎的主要工作都是在一个单独的后台线程Master Thread中完成的。</p>
<h3 id="31-ｉnnodb-10x版本之前的master-thread">3.1 ＩnnoDB 1.0.x版本之前的Master Thread</h3>
<p>Master Thread 具有最高的线程优先级别，内部由多个循环(loop)组成:</p>
<ul>
<li>主循环(loop)</li>
<li>后台循环(background loop)</li>
<li>刷新循环(flush loop)</li>
<li>暂停循环(suspend loop)<br>
Master Thread会根据数据库运行状态在这些循环中进行切换。</li>
</ul>
<h4 id="311-主循环loop">3.1.1 主循环(loop)</h4>
<blockquote>
<p>大多数的操作是在这个循环中，其中有两大部分的操作: 每秒钟和每10秒的操作。<br>
Loop循环是通过thread sleep来实现，这意味着不精确的操作在负载大的情况下会有延迟。<br>
但InnoDB通过其它方法来尽量保证这个频率。</p>
</blockquote>
<blockquote>
<p>每秒一次的操作包括：</p>
</blockquote>
<ul>
<li>
<ol>
<li>日志缓冲刷新到磁盘，即使这个事务还未提交（总是）</li>
</ol>
</li>
</ul>
<pre><code>即使某个事务还未提交，InnoDB存储引擎仍然会每秒将重做日志缓冲中的内容刷新到重做日志文件；
所以再大的事务提交的时间也是很短的。
</code></pre><ul>
<li>
<ol start="2">
<li>合并插入缓冲(可能)</li>
</ol>
</li>
</ul>
<pre><code>合并插入缓冲(Insert Buffer)并不是每秒都会发生的；InnoDB会判断当前一秒内发生的IO次数是否小于5次，
若小于5次，InnoDB认为当前的IO压力很小，可以执行合并插入缓冲的操作。
</code></pre><ul>
<li>
<ol start="3">
<li>至多刷新100个InnoDB的缓冲池中的脏页到磁盘(可能)</li>
</ol>
</li>
</ul>
<pre><code>InnoDB存储引擎通过判断当前缓冲池中脏页的比例(buf_get_modified_ratio_pct)是否超过了配置文件中innodb_max_dirty_pages_pct这个参数(默认为90％)；
若超过了这个阈值，则需要将100个脏页到磁盘中。
</code></pre><ul>
<li>
<ol start="4">
<li>如果当前无用户活动，则切换到background loop(可能)</li>
</ol>
</li>
</ul>
<blockquote>
<p>每10秒的操作：</p>
</blockquote>
<ul>
<li>
<ol>
<li>刷新100个脏页到磁盘(可能的情况下)</li>
</ol>
</li>
<li>
<ol start="2">
<li>合并至多5个插入缓冲(总是)</li>
</ol>
</li>
<li>
<ol start="3">
<li>将日志缓冲刷新到磁盘（总是）</li>
</ol>
</li>
<li>
<ol start="4">
<li>删除无用的Undo页(总是)</li>
</ol>
</li>
<li>
<ol start="5">
<li>刷新100个或10个脏页到磁盘(总是)</li>
</ol>
</li>
</ul>
<blockquote>
<p>若过去10秒内磁盘的IO操作是否小于200，则InnoDB认为当前有足够的磁盘IO操作能力，因此将100个脏页刷新到磁盘；<br>
然后InnoDB会合并插入缓冲，这次的合并插入缓冲操作总是会在这个阶段进行。<br>
之后，InnoDB会进行一次将日志缓冲刷新到磁盘的操作。<br>
接着InnoDB会执行full purge操作: 删除无用的Undo页;</p>
</blockquote>
<pre><code>对表进行update、delete操作时，原先的行被标记为删除, 但为了一致性读的关系(consistent read),需要保留这些行的版本信息。
但在full purge过程中，InnoDB会判断当前事务系统中已被删除的行是否可以被删除（比如有时会有查询操作需要读取之前版本的undo信息），若是，则InnoDB会立即将其删除。
InnoDB在执行pull purge时，每次最多尝试回收20个undo页。
</code></pre><blockquote>
<p>然后，InnoDB会判断缓冲池中脏页的比例(buf_get_modified_ratio_pct), 若有超过70％的脏页，则刷新100个脏页到磁盘； 否则只需刷新10％的脏页到磁盘。</p>
</blockquote>
<h4 id="312-background-loop">3.1.2 background loop</h4>
<p>若当前无用户活动(数据库空闲时)或数据库关闭(shutdown),则会切换到这个循环。<br>
background loop会执行以下操作:</p>
<ul>
<li>删除无用的Undo页(总是)</li>
<li>合并20个插入缓冲(总是)</li>
<li>跳回到主循环(总是)</li>
<li>不断刷新100个页直到符合条件(可能，跳到flush loop中完成)。</li>
</ul>
<blockquote>
<p>若flush loop中也无事可做，InnoDB会切换到suspend_loop, 将 Master Thread 挂起，等等事件的发生。<br>
若用户启用了InnoDB存储引擎，但没有使用任何InnoDB存储引擎的表，则 Master Thread 将问题处于挂起状态。</p>
</blockquote>
<blockquote>
<p>master thread 完整伪代码:</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="nf">master_thread</span><span class="p">(){</span>
  <span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
<span class="nl">loop</span><span class="p">:</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">thread_sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">do</span> <span class="n">log</span> <span class="n">buffer</span> <span class="n">flush</span> <span class="n">to</span> <span class="n">disk</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">last_one_second_ios</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">do</span> <span class="n">merge</span> <span class="n">at</span> <span class="n">most</span> <span class="mi">5</span> <span class="n">insert</span> <span class="n">buffer</span> <span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">buf_get_modified_ratio_pct</span> <span class="o">&gt;</span> <span class="n">innodb_max_dirty_pages_pct</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">do</span> <span class="n">buffer</span> <span class="n">pool</span> <span class="n">flush</span> <span class="mi">100</span> <span class="n">dirty</span> <span class="n">pages</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">no</span> <span class="n">user</span> <span class="n">activity</span><span class="p">){</span>
      <span class="k">goto</span> <span class="n">background</span> <span class="n">loop</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// do things once per ten second;
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">last_ten_seconds_ios</span> <span class="o">&lt;</span> <span class="mi">200</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">do</span> <span class="n">buffer</span> <span class="n">pool</span> <span class="n">flush</span> <span class="mi">100</span> <span class="n">dirty</span> <span class="n">pages</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">do</span> <span class="n">merge</span> <span class="n">at</span> <span class="n">most</span> <span class="mi">5</span> <span class="n">insert</span> <span class="n">buffer</span><span class="p">;</span>
  <span class="k">do</span> <span class="n">log</span> <span class="n">buffer</span> <span class="n">flush</span> <span class="n">to</span> <span class="n">disk</span><span class="p">;</span>
  <span class="k">do</span> <span class="n">full</span> <span class="n">purge</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">buf_get_modified_ratio_pct</span> <span class="o">&gt;</span> <span class="mi">70</span><span class="o">%</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">do</span> <span class="n">buffer</span> <span class="n">pool</span> <span class="n">flush</span> <span class="mi">100</span> <span class="n">dirty</span> <span class="n">pages</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">buffer</span> <span class="n">pool</span> <span class="n">flush</span> <span class="mi">10</span> <span class="n">dirty</span> <span class="n">pages</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">goto</span> <span class="n">loop</span>

<span class="n">background</span> <span class="nl">loop</span><span class="p">:</span>
    <span class="k">do</span> <span class="n">full</span> <span class="n">purge</span><span class="p">;</span>
    <span class="k">do</span> <span class="n">merge</span> <span class="mi">20</span> <span class="n">insert</span> <span class="n">buffers</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">not</span> <span class="n">idle</span> <span class="p">{</span>
      <span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">goto</span> <span class="n">flush</span> <span class="n">loop</span><span class="p">;</span>
    <span class="p">}</span>

<span class="n">flush</span> <span class="nl">loop</span><span class="p">:</span>
  <span class="k">do</span> <span class="n">buffer</span> <span class="n">pool</span> <span class="n">flush</span> <span class="mi">100</span> <span class="n">dirty</span> <span class="n">pages</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">buf_get_modified_ratio_pct</span> <span class="o">&gt;</span> <span class="n">innodb_max_dirty_pages_pct</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">goto</span> <span class="n">flush</span> <span class="n">loop</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">goto</span> <span class="n">suspend</span> <span class="n">loop</span><span class="p">;</span>

<span class="n">suspend</span> <span class="nl">loop</span><span class="p">:</span>
  <span class="n">suspend_thread</span><span class="p">()</span>
  <span class="n">waiting</span> <span class="k">for</span> <span class="n">events</span><span class="p">;</span>
  <span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="32-innodb-12x版本之前的-master-thread">3.2 InnoDB 1.2.x版本之前的 Master Thread</h3>
<p>在 1.0.x之前的Master Thread实现中，InnoDB对于IO是有限制的: 在缓冲池向磁盘刷新时做了一定的硬编码(hard coding)。<br>
但这种限制限制了InnoDB对（SSD）磁盘IO的性能，尤其是写入性能。</p>
<pre><code>伪代码显示，InnoDB最大只会刷新100个脏页到磁盘，合并20个插入缓冲。
但在写入密集型的应用中，每秒会产生大于100个的脏页，和大于20个的插入缓冲，此时Master Thread将会很慢。
同时，若从宕机中恢复时，由于大量数据未刷新到磁盘，会导致恢复的时间太久；尤其是insert buffer。
</code></pre><h4 id="321-innodb_io_capacity">3.2.1 innodb_io_capacity</h4>
<p>但在InnoDB Pluin(InnoDB1.0.x版本开始)中提供了参数 innodb_io_capacity,其表示磁盘IO的吞吐时不时，默认值为200。<br>
要刷新到磁盘的页的数量，根据 innodb_io_capacity 的百分比来进行控制：</p>
<ul>
<li>在合并插入缓冲时，合并插入缓冲的数量为 innodb_io_capacity 值的 5％</li>
<li>在从缓冲区刷新脏页时，刷新脏页的数量为 innodb_io_capacity</li>
</ul>
<p>若用户使用了高性能磁盘，可以调高 innodb_io_capacity的值，使其符合磁盘IO的吞吐量。</p>
<h4 id="322-innodb_max_dirty_pages_pct">3.2.2 innodb_max_dirty_pages_pct</h4>
<p>另外，innodb_max_dirty_pages_pct 的默认值在 InnoDB 1.0.x 版本之前是90，有点太大了；<br>
InnoDB在每秒刷新缓冲池和flush loop时会判断该值，若该值大于innodb_max_dirty_pages_pct，才刷新100个脏页，<br>
若有很大的内存或数据库服务器的压力过大，此时刷新脏页的速度反而会下降；同时宕机恢复阶段会耗时更久。<br>
经过测试， innodb_max_dirty_pages_pct默认值变为了75；这样即加快了刷新脏页的频率，又保证了磁盘IO的负载。</p>
<h4 id="323-innodb_adaptive_flushing自适应地刷新">3.2.3 innodb_adaptive_flushing（自适应地刷新)</h4>
<p>该值影响每秒刷新脏页的数量，InnoDB会通过一个 buf_flush_get_desired_flush_rate 函数来判断需要刷新脏页最合适的数量。<br>
buf_flush_get_desired_flush_rate 通过判断产生重做日志的速度来决定最合适的刷新脏页数量。<br>
因此，当脏页在缓冲池中的比例小于 innodb_max_dirty_pages_pct 时，也会刷新一定量的脏页。</p>
<h4 id="324-innodb_purge_batch_size">3.2.4 innodb_purge_batch_size</h4>
<p>该参数控制每次full purge回收的Undo页的数量，其默认值为20，可以动态地对其进行修改。</p>
<div class="highlight"><pre class="chroma"><code class="language-MySQL" data-lang="MySQL"><span class="n">mysql</span> <span class="n">root</span><span class="o">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">:</span><span class="n">test</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;innodb_max_dirty_pages_pct&#39;</span><span class="err">\</span><span class="n">G</span>
<span class="o">***************************</span><span class="p">[</span> <span class="mi">1</span><span class="p">.</span> <span class="n">row</span> <span class="p">]</span><span class="o">***************************</span>
<span class="n">Variable_name</span> <span class="o">|</span> <span class="n">innodb_max_dirty_pages_pct</span>
<span class="n">Value</span>         <span class="o">|</span> <span class="mi">90</span><span class="p">.</span><span class="mi">000000</span>

<span class="mi">1</span> <span class="n">row</span> <span class="k">in</span> <span class="kt">set</span>
<span class="kt">Time</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">010</span><span class="n">s</span>
<span class="n">mysql</span> <span class="n">root</span><span class="o">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">:</span><span class="n">test</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;innodb_purge_batch_size&#39;</span><span class="err">\</span><span class="n">G</span>
<span class="o">***************************</span><span class="p">[</span> <span class="mi">1</span><span class="p">.</span> <span class="n">row</span> <span class="p">]</span><span class="o">***************************</span>
<span class="n">Variable_name</span> <span class="o">|</span> <span class="n">innodb_purge_batch_size</span>
<span class="n">Value</span>         <span class="o">|</span> <span class="mi">300</span>

<span class="mi">1</span> <span class="n">row</span> <span class="k">in</span> <span class="kt">set</span>
<span class="kt">Time</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">009</span><span class="n">s</span>
<span class="n">mysql</span> <span class="n">root</span><span class="o">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">:</span><span class="n">test</span><span class="o">&gt;</span> <span class="kt">set</span> <span class="n">global</span> <span class="n">innodb_purge_batch_size</span><span class="o">=</span><span class="mi">500</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="n">rows</span> <span class="n">affected</span>
<span class="kt">Time</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">000</span><span class="n">s</span>
</code></pre></div><p>从 InnoDB 1.0.x 版本开始， Master Thread 的伪代码会变为：</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="nf">master_thread</span><span class="p">(){</span>
  <span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
<span class="nl">loop</span><span class="p">:</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">thread_sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">do</span> <span class="n">log</span> <span class="n">buffer</span> <span class="n">flush</span> <span class="n">to</span> <span class="n">disk</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">last_one_second_ios</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">%</span> <span class="n">innodb_io_capacity</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">do</span> <span class="n">merge</span> <span class="mi">5</span><span class="o">%</span> <span class="n">innodb_io_capacity</span> <span class="n">of</span> <span class="n">insert</span> <span class="n">buffer</span> <span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">buf_get_modified_ratio_pct</span> <span class="o">&gt;</span> <span class="n">innodb_max_dirty_pages_pct</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">do</span> <span class="n">buffer</span> <span class="n">pool</span> <span class="n">flush</span> <span class="mi">100</span><span class="o">%</span> <span class="n">innodb_io_capacity</span> <span class="n">of</span> <span class="n">dirty</span> <span class="n">pages</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">enable</span> <span class="n">adaptive_flush</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">do</span> <span class="n">buffer</span> <span class="n">pool</span> <span class="n">flush</span> <span class="n">desired</span> <span class="n">amount</span> <span class="n">of</span> <span class="n">dirty</span> <span class="n">pages</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">no</span> <span class="n">user</span> <span class="n">activity</span><span class="p">){</span>
      <span class="k">goto</span> <span class="n">background</span> <span class="n">loop</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// do things once per ten second;
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">last_ten_seconds_ios</span> <span class="o">&lt;</span> <span class="n">innodb_io_capacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">do</span> <span class="n">buffer</span> <span class="n">pool</span> <span class="n">flush</span> <span class="mi">100</span><span class="o">%</span> <span class="n">innodb_io_capacity</span> <span class="n">of</span> <span class="n">dirty</span> <span class="n">pages</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">do</span> <span class="n">merge</span> <span class="mi">5</span><span class="o">%</span> <span class="n">innodb_io_capacity</span> <span class="n">of</span> <span class="n">insert</span> <span class="n">buffer</span><span class="p">;</span>
  <span class="k">do</span> <span class="n">log</span> <span class="n">buffer</span> <span class="n">flush</span> <span class="n">to</span> <span class="n">disk</span><span class="p">;</span>
  <span class="k">do</span> <span class="n">full</span> <span class="n">purge</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">buf_get_modified_ratio_pct</span> <span class="o">&gt;</span> <span class="mi">70</span><span class="o">%</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">do</span> <span class="n">buffer</span> <span class="n">pool</span> <span class="n">flush</span> <span class="mi">100</span><span class="o">%</span> <span class="n">innodb_io_capacity</span> <span class="n">of</span> <span class="n">dirty</span> <span class="n">pages</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">buffer</span> <span class="n">pool</span> <span class="n">flush</span> <span class="mi">10</span><span class="o">%</span> <span class="n">innodb_io_capacity</span> <span class="n">of</span> <span class="n">dirty</span> <span class="n">pages</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">goto</span> <span class="n">loop</span>

<span class="n">background</span> <span class="nl">loop</span><span class="p">:</span>
    <span class="k">do</span> <span class="n">full</span> <span class="n">purge</span><span class="p">;</span>
    <span class="k">do</span> <span class="n">merge</span> <span class="mi">100</span><span class="o">%</span> <span class="n">innodb_io_capacity</span> <span class="n">of</span> <span class="n">insert</span> <span class="n">buffers</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">not</span> <span class="n">idle</span> <span class="p">{</span>
      <span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">goto</span> <span class="n">flush</span> <span class="n">loop</span><span class="p">;</span>
    <span class="p">}</span>

<span class="n">flush</span> <span class="nl">loop</span><span class="p">:</span>
  <span class="k">do</span> <span class="n">buffer</span> <span class="n">pool</span> <span class="n">flush</span> <span class="mi">100</span><span class="o">%</span> <span class="n">innodb_io_capacity</span> <span class="n">dirty</span> <span class="n">pages</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">buf_get_modified_ratio_pct</span> <span class="o">&gt;</span> <span class="n">innodb_max_dirty_pages_pct</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">goto</span> <span class="n">flush</span> <span class="n">loop</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">goto</span> <span class="n">suspend</span> <span class="n">loop</span><span class="p">;</span>

<span class="n">suspend</span> <span class="nl">loop</span><span class="p">:</span>
  <span class="n">suspend_thread</span><span class="p">()</span>
  <span class="n">waiting</span> <span class="k">for</span> <span class="n">events</span><span class="p">;</span>
  <span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>查看 master thread 的状态</p>
</blockquote>
<p><img src="/post/mysql_innodb/images/master_thread_status_1.0.x.png" alt="master_thread_status_1.0.x"  /></p>
<pre><code>45 1_second：  主循环进行了45次
45 sleeps:    每秒挂起的操作进行了45次，说明负载不大
4 10_second:  10秒一次的活动进行了4次，符合 1:10.
6 background: background loop 进行了6次
6 flush:      flush loop也进行了6次
</code></pre><h3 id="33-innodb-12x版本的-master-thread">3.3 InnoDB 1.2.x版本的 Master Thread</h3>
<p>InnoDB 1.2.x再次对 Master Thread 进行了优化。<br>
伪代码</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="k">if</span> <span class="n">InnoDB</span> <span class="n">is</span> <span class="n">idle</span> <span class="p">{</span>
  <span class="n">srv_master_do_idle_tasks</span><span class="p">();</span>     <span class="c1">// 之前版本中每10秒的操作
</span><span class="c1"></span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">srv_master_do_active_tasks</span><span class="p">();</span>   <span class="c1">// 之前每秒中的操作
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>srv_master_do_idle_tasks() 是之前版本中每10秒的操作，<br>
srv_master_do_active_tasks() 是之前每秒中的操作，<br>
同时对于刷新脏页的操作，从 Master Thread 线程分享到一个单独的 Page Cleaner Thread，<br>
从而减轻了 Master Thread 的工作，提高了系统的并发性。</p>
<h2 id="4-innodb-关键特性">4. InnoDB 关键特性</h2>
<ul>
<li>插入缓冲(Insert Buffer)</li>
<li>两次写(Double Write)</li>
<li>自适应哈希索引(Adaptive Hash Index)</li>
<li>异步IO(Async IO)</li>
<li>刷新邻接页(Flush Neighbor Page)<br>
上述特性为InnoDB存储引擎带来更好的性能和可靠性。</li>
</ul>
<h3 id="41-插入缓冲">4.1 插入缓冲</h3>
<h4 id="1-insert-buffer">1. Insert Buffer</h4>
<p>Insert Buffer 和数据页一样，是物理页的一个组成部分。<br>
在InnoDB中，主键是行唯一的标识符，行记录的插入顺序是按主键递增的顺序进行插入的；<br>
因此插入聚集索引(Primary Key)是按顺序的，不需要磁盘的随机读取。</p>
<blockquote>
<p>但若主键类是 UUID 这样的类，则插入和辅助索引一样，都是随机的<br>
若插入的自增主键是指定的值，而不是NULL，则也可能导致非连续插入。</p>
</blockquote>
<p>若数据表中有一个非唯一聚集索引，则在进行插入操作时，数据页的存放还是按主键进行顺序存放的，<br>
但是对于非聚集索引叶子节点的插入不是顺序的，这时需要离散地访问非聚集索引页，<br>
由于随机读取的存在导致了插入操作的性能下降。</p>
<blockquote>
<p>在某些情况下，辅助索引的插入是(比较)顺序的，如时间字段。</p>
</blockquote>
<p>对于非聚集索引的插入和更新操作，并非每次都直接插入到索引中，而是先判断插入的非聚集索引页是否在缓冲池中，<br>
若在，则直接插入；否则先放入到一个 Insert Buffer 对象中。<br>
然后以一定的频率和情况进行 Insert Buffer 和 辅助索引叶子节点的 merge 操作，<br>
通过将多个插入合并到一个操作中，大大提高了非聚集索引的插入性能。</p>
<blockquote>
<p>Insert Buffer 的使用需要同时满足以下两个条件:</p>
</blockquote>
<ul>
<li>索引是辅助索引 (secondary index)</li>
<li>索引不是唯一的 (not unique)</li>
</ul>
<blockquote>
<p>但若程序进行大量的插入操作，且都涉及了不唯一的非聚集索引(使用了 Insert Buffer)，若此时数据库宕机，<br>
会有大量的 Insert Buffer 未合并到非聚集索引中去，此时恢复时间会很长。</p>
</blockquote>
<blockquote>
<p>辅助索引不能是唯一的， 因为在插入缓冲时，数据库并不去查找索引页来判断插入记录的唯一性一。</p>
</blockquote>
<p><img src="/post/mysql_innodb/images/insert_buffer_status.png" alt="insert_buffer_status"  /><br>
上图中显示了插入缓冲的状态信息：</p>
<pre><code>seg size:       当前 Insert Buffer 的大小为11336 x 16KB = 177MB
free list len:  空闲列表的长度
size：          已经合并记录页的数量
</code></pre><p>黑体部分第2行显示了插入性能的提高:</p>
<pre><code>inserts：      插入的记录数
merged recs:  合并的插入记录数
merges:       合并的次数，即实际读取页的次数
</code></pre><p>merges : merged recs 大约为 1:3, 表示插入缓冲将对于非聚集索引页的离散IO逻辑请求大约降低了2/3。</p>
<blockquote>
<p>Insert Buffer存在一个问题：在写密集的情况下，插入缓冲会战胜过多的缓冲池内存(innodb_buffer_pool),<br>
默认最大可占用1/2的缓冲池内存。这将对其它操作带来一定的影响。<br>
修改 IBUF_POOL_SIZE_PER_MAX_SIZE 可对插入缓冲的大小进行控制，如将其值改为3，则最大用1/3的缓冲池内存。</p>
</blockquote>
<h4 id="2-change-buffer">2. Change Buffer</h4>
<p>InnoDB 从1.0.x开始引入了 Change Buffer, 可以对 DML操作(INSERT, DELETE, UPDATE)都进行缓冲: Insert Buffer, Delete Buffer, Purge Buffer。</p>
<blockquote>
<p>Change Buffer适用的对象也是非唯一的辅助索引<br>
对一条记录的UPDATE操作分为两个过程:</p>
</blockquote>
<ul>
<li>将记录票房为已删除</li>
<li>真正将记录删除</li>
</ul>
<blockquote>
<p>Delete Buffer 对应UPDATE操作的第一个过程: 将记录标记为删除<br>
Purge Buffer 对应UPDATE操作的第二个过程: 将记录真正地删除</p>
</blockquote>
<h5 id="1-innodb_change_buffering-参数">1. innodb_change_buffering 参数</h5>
<blockquote>
<p>参数 innodb_change_buffering 用来开发各种Buffer的选项: inserts, deletes, purges, changes, all, none。</p>
</blockquote>
<p>inserts, deletes, purges 为前面讨论过的三种情况，<br>
changes 表示启用inserts 和 deletes<br>
all 表示启用所有<br>
none表示都不启用</p>
<blockquote>
<p>该参数默认值为 all</p>
</blockquote>
<h5 id="2-innodb_change_buffer_max_size-参数">2. innodb_change_buffer_max_size 参数</h5>
<p>参数 innodb_change_buffer_max_size 用来控制 Change Buffer 可使用的最大内存数量</p>
<div class="highlight"><pre class="chroma"><code class="language-MySQL" data-lang="MySQL"><span class="n">mysql</span> <span class="n">root</span><span class="o">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">:</span><span class="n">test</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;innodb_change_buffer_max_size&#39;</span> <span class="err">\</span><span class="n">G</span>
<span class="o">***************************</span><span class="p">[</span> <span class="mi">1</span><span class="p">.</span> <span class="n">row</span> <span class="p">]</span><span class="o">***************************</span>
<span class="n">Variable_name</span> <span class="o">|</span> <span class="n">innodb_change_buffer_max_size</span>
<span class="n">Value</span>         <span class="o">|</span> <span class="mi">25</span>

<span class="mi">1</span> <span class="n">row</span> <span class="k">in</span> <span class="kt">set</span>
<span class="kt">Time</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">011</span><span class="n">s</span>
</code></pre></div><blockquote>
<p>默认值为25，表示最多使用1/4的缓冲池内存空间，该参数的最大有效值为50</p>
</blockquote>
<blockquote>
<p>通过命令 SHOW ENGINE INNODB STATUS 查看状态：</p>
</blockquote>
<pre><code>-------------------------------------
INSERT BUFFER AND ADAPTIVE HASH INDEX
-------------------------------------
Ibuf: size 1, free list len 3078, seg size 3080, 0 merges
merged operations:
 insert 0, delete mark 0, delete 0
discarded operations:
 insert 0, delete mark 0, delete 0
</code></pre><p>merged operations 和 discard operations 下面显示 Change Buffer 中每个操作的次数:</p>
<pre><code>insert 表示 Insert Buffer
delete mark 表示 Delete Buffer
delete 表示 Purge Buffer
</code></pre><p>discard operations 表示当Change Buffer 发生 merge 时，表已经被删除，无需将记录 merge 到辅助索引中。</p>
<h4 id="3-insert-buffer-的内部实现">3. Insert Buffer 的内部实现</h4>
<blockquote>
<ol>
<li>Insert Buffer的数据结构是一棵B+树。<br>
在MySQL4.1之前的版本中，每张表都有一棵Insert Buffer B+树； 但在现在的版本中，只有一棵全局Insert Buffer B+树，负责对所有的表的辅助索引进行Insert Buffer。<br>
这棵B+树位于共享表空间中，默认为 ibdata1中。<br>
因此，若试图通过独立表空间ibd文件恢复表中数据是地，会导致 CHECK TABLE 失败，因为表的辅助索引中的数据可能还在 Insert Buffer中，所以对 ibd 文件进行恢复后，还要进行 REPAIR TABLE 操作来重建表上的所有辅助索引。</li>
</ol>
</blockquote>
<p>Insert Buffer 的 B+村中，非叶子节点存放的是查询键值(search key)， 构造如下图:<br>
<img src="/post/mysql_innodb/images/insert_buffer_tree_not_leaf.png" alt="insert_buffer_tree_not_leaf"  /></p>
<blockquote>
<p>search key 共占用9个字节:</p>
</blockquote>
<ul>
<li>space 占用4字节，表示待插入记录所在表的表空间id, InnoDb存储引擎的每个表有一个唯一的 space id，可以通过 space id查询得知是哪张表。</li>
<li>marker 占用 1 字节，用来兼容老版本的 Insert Buffer</li>
<li>offset 占用 4 字节，表示页所在的偏移量</li>
</ul>
<pre><code>当一个辅助索引要插入到页(space, offset)时，若该页不在缓冲池中，则InnoDB会先按上述规则构造一个search key,
然后查询 Insert Buffer 这棵B+树，再将这条记录插入到 Insert Buffer B+ 树的叶子节点中。
</code></pre><p>对于插入到叶子节点的记录，并非直接将待插入的记录插入，面是需要根据如下的规则进行构造:<br>
<img src="/post/mysql_innodb/images/insert_buffer_tree_leaf.png" alt="insert_buffer_tree_leaf"  /></p>
<ul>
<li>metadata 占用 4 字节，其内容如下表所示:</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>字节</th>
</tr>
</thead>
<tbody>
<tr>
<td>IBUF_REC_OFFSET_COUNT</td>
<td>2</td>
</tr>
<tr>
<td>IBUF_REC_OFFSET_TYPE</td>
<td>1</td>
</tr>
<tr>
<td>IBUF_REC_OFFSET_FLAGS</td>
<td>1</td>
</tr>
</tbody>
</table>
<ul>
<li>IBUF_REC_OFFSET_COUNT 保存两个字节的整数，用来排序每个记录进入Insert Buffer的顺序。</li>
</ul>
<blockquote>
<p>从 Insert Buffer 叶子节点的第5列开始(secondary index record)，就是实际插入记录的各个字段了。</p>
</blockquote>
<blockquote>
<ol start="2">
<li>Insert Buffer Bitmap<br>
启用Insert Buffer 索引后，辅助索引页(space, page_no)中的记录可能被插入到 Insert Buffer B+树中，<br>
为保证Merge Insert Buffer页成功，要有一个特殊的页（Insert Buffer Bitmap）来标记每个辅助索引页(space, page_no)的可用空间。</li>
</ol>
</blockquote>
<p>每个Insert Buffer Bitmap页可追踪16384个辅助索引页，即256个区(Extent).<br>
每个Insert Buffer Bitmap页都在在16364个页的第二个页中。<br>
每个辅助索引页在 Insert Buffer Bitmap 页中占用 4 位，由下表中的三个部分组成：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小(bit)</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>IBUF_BITMAP_FREE</td>
<td>2</td>
<td>表示该辅助索引页中的可用空间数量，可取值为:<!-- raw HTML omitted -->０: 无可用剩余空间　<!-- raw HTML omitted -->1：剩余空间大于1/32页(512字节)<!-- raw HTML omitted -->2: 剩余空间大于1/16页<!-- raw HTML omitted -->3: 剩余空间大于1/8页</td>
</tr>
<tr>
<td>IBUF_BITMAP_BUFFERED</td>
<td>1</td>
<td>1 表示该辅助索引页有记录被缓存到 Insert Buffer B+树中</td>
</tr>
<tr>
<td>IBUF_BITMAP_IBUF</td>
<td>1</td>
<td>1 表示该页为 Insert Buffer B+树的索引页</td>
</tr>
</tbody>
</table>
<blockquote>
<p>4 Merge Insert Buffer<br>
若要实现插入记录的辅助索引页不在缓冲池中，则须将辅助索引记录先插入到这棵B＋树中，<br>
Merge Insert Buffer的操作可能发生在以下几种情况下:</p>
</blockquote>
<ul>
<li>辅助索引页被读取到缓冲池时</li>
</ul>
<pre><code>在执行正常的SELECT查询操作时，要检查Insert Buffer Bitmap页，然后确认该辅助索引页是否有记录在Insert Buffer B+树中；
若有，则将B+树中该页的记录插入到该辅助索引页中；
对该页多次的记录操作通过一次操作合并到了原有的辅助页中，会大幅提高性能。
</code></pre><ul>
<li>Insert Buffer Bitmap 页追踪到该辅助索引页无可用空间时</li>
</ul>
<pre><code>若插入辅助索引记录时检测到插入记录后可用空间小于1/32页，则会强制进行一次合并操作: 强制读取辅助索引页，将Insert Buffer B+树中该页的记录及待插入的记录插入到辅助索引页中。
</code></pre><ul>
<li>Master Thread</li>
</ul>
<pre><code>在Master Thread线程中每秒或每十少会进行一次 Merge Insert Buffer 的操作，但每次merge的页数量不同。
</code></pre><blockquote>
<p>虽然辅助索引页是排好序的，但对于 Insert Buffer 页的选择，InnoDB随机地选择Insert Buffer B+树的一个页，读取该页中的space及之后所需要数量的页。<br>
若进行 merge 时，要进行 merge 的胶已经被删除，则可以直接选择已经被 Insert/Change Buffer 的数据记录。</p>
</blockquote>
<p>4.2 两次写</p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/mysql/">MySQL</a>
        
            <a href="/tags/innodb/">InnoDB</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>

    
</article>

    <aside class="related-contents--wrapper">
    
    
</aside>


    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2021 Li. Mingzhi
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="2.2.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >
            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
