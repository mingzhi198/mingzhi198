<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='Statement  This article is my study notes from the book: grokking algorithm: an illustrated guide for programmers and other curious people. Please refer to the original work for more details and indicate the source for reprinting.   This chapter I learned divide-and-conquer and quicksort, both of which can help me solve problems elegently.
 1. Divide &amp;amp; Conquer  It can take us some time to understand D&amp;amp;C. Therefore, we will see some problems to learn about it.'><title>GA: 4. Quicksort</title>

<link rel='canonical' href='/p/ga-4.-quicksort/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='GA: 4. Quicksort'>
<meta property='og:description' content='Statement  This article is my study notes from the book: grokking algorithm: an illustrated guide for programmers and other curious people. Please refer to the original work for more details and indicate the source for reprinting.   This chapter I learned divide-and-conquer and quicksort, both of which can help me solve problems elegently.
 1. Divide &amp;amp; Conquer  It can take us some time to understand D&amp;amp;C. Therefore, we will see some problems to learn about it.'>
<meta property='og:url' content='/p/ga-4.-quicksort/'>
<meta property='og:site_name' content='Li. Mingzhi'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='algorithm' /><meta property='article:tag' content='quick sort' /><meta property='article:tag' content='sort' /><meta property='article:published_time' content='2020-12-09T08:32:27&#43;08:00'/><meta property='article:modified_time' content='2020-12-09T08:32:27&#43;08:00'/>
<meta name="twitter:title" content="GA: 4. Quicksort">
<meta name="twitter:description" content="Statement  This article is my study notes from the book: grokking algorithm: an illustrated guide for programmers and other curious people. Please refer to the original work for more details and indicate the source for reprinting.   This chapter I learned divide-and-conquer and quicksort, both of which can help me solve problems elegently.
 1. Divide &amp;amp; Conquer  It can take us some time to understand D&amp;amp;C. Therefore, we will see some problems to learn about it.">
    </head>
    <body class="">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            localStorage.setItem(colorSchemeKey, "auto");
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.body.dataset.scheme = 'dark';
        } else {
            document.body.dataset.scheme = 'light';
        }
    })();
</script><div class="container main-container flex on-phone--column extended article-page with-toolbar">
            <aside class="sidebar left-sidebar sticky">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header class="site-info">
        
            <figure class="site-avatar">
                
                    
                    
                    
                        
                        <img src="/images/avatar_hu518c5ba2d560f0e95b4ebe9ab0244799_30403_300x0_resize_q75_box.jpeg" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                

                
            </figure>
        
        <h1 class="site-name"><a href="">Li. Mingzhi</a></h1>
        <h2 class="site-description">I am a Backend Software Engineer focusing on system design and algorithm(^_^). 
        Progress one percent per day...</h2>
    </header>

    <ol class="menu" id="main-menu">
        
        
        

        <li >
            <a href='/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        

        <li >
            <a href='/p/resume/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>About Me</span>
            </a>
        </li>
        
        

        <li >
            <a href='/archives/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        

        <li >
            <a href='/search/index.html'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        

        
    </ol>
</aside>

            <main class="main full-width">
    <div id="article-toolbar">
        <a href="" class="back-home">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



            <span>Back</span>
        </a>
    </div>

    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/grokking_algorithm/" >
                grokking_algorithm
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/ga-4.-quicksort/">GA: 4. Quicksort</a>
    </h2>

    <footer class="article-time">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <time class="article-time--published">Dec 09, 2020</time>
    </footer></div>
</header>

    <section class="article-content">
    <h1 id="statement">Statement</h1>
<ul>
<li>This article is my study notes from the book: grokking algorithm: an illustrated guide for programmers and other curious people.</li>
<li>Please refer to the original work for more details and indicate the source for reprinting.</li>
</ul>
<blockquote>
<p>This chapter I learned divide-and-conquer and quicksort, both of which can help me solve problems elegently.</p>
</blockquote>
<h3 id="1-divide--conquer">1. Divide &amp; Conquer</h3>
<blockquote>
<p>It can take us some time to understand D&amp;C. Therefore, we will see some problems to learn about it.</p>
</blockquote>
<h4 id="example">Example</h4>
<p>If you are a farmer with a large land and plan to divide this farmland evenly into square plots.<br>
Besides, the plots must be as big as possible.<br>
Before continuing your reading, think about how can you solve this problem?</p>
<p>We can use D&amp;C(Divde &amp; Conquer) to solve this problem.<br>
To solve a problem using D&amp;C, we should follow two steps:</p>
<pre><code>1. Figure out the base case, which should be the simplest possible case.
2. Divide or decrease you problem until it becomes the base case.
</code></pre><p>Suppose you have a land of 30 * 50, now you have the largest square with side of 30.<br>
We have the rest of the land(20 * 30) and have the largest square of 20 * 20.<br>
Then we are left with a land of 10 * 10, which is the answer.</p>
<ul>
<li>Golang</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-Golang" data-lang="Golang"><span class="kd">func</span> <span class="nf">findMaxEvenSquareR</span><span class="p">(</span><span class="nx">width</span><span class="p">,</span> <span class="nx">height</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="mi">0</span> <span class="o">==</span> <span class="nx">height</span> <span class="o">||</span> <span class="mi">0</span> <span class="o">==</span> <span class="nx">width</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">height</span> <span class="o">+</span> <span class="nx">width</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">height</span> <span class="p">&gt;</span> <span class="nx">width</span> <span class="p">{</span>
		<span class="nx">height</span> <span class="p">=</span> <span class="nx">height</span> <span class="o">%</span> <span class="nx">width</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">width</span> <span class="p">=</span> <span class="nx">width</span> <span class="o">%</span> <span class="nx">height</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">findMaxEvenSquareR</span><span class="p">(</span><span class="nx">width</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="2-exercises">2. Exercises:</h3>
<ol>
<li>Add up all numbers and return the total.</li>
</ol>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-Python" data-lang="Python"><span class="k">def</span> <span class="nf">sumR</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
    <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">sumR</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</code></pre></div><ul>
<li>Golang</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-Golang" data-lang="Golang"><span class="kd">func</span> <span class="nf">sumR</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">total</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nf">sumR</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
<span class="p">}</span>
</code></pre></div><ol start="2">
<li>Write a recursive function to count the number of elements in a list</li>
</ol>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-Python" data-lang="Python"><span class="k">def</span> <span class="nf">countEleR</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span> 
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span> 
    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">countEleR</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</code></pre></div><ol start="3">
<li>Find the maximum number in a list</li>
</ol>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-Python" data-lang="Python"><span class="k">def</span> <span class="nf">findMaxR</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span> 
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">findMaxR</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ret</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ret</span> 
</code></pre></div><ol start="4">
<li>Write the D&amp;C code for Binary Search</li>
</ol>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-Python" data-lang="Python"><span class="k">def</span> <span class="nf">binarySearchR</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">low</span> <span class="o">&gt;</span> <span class="n">high</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span> 

    <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">guess</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">guess</span> <span class="o">&gt;</span> <span class="n">item</span><span class="p">:</span> 
        <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span><span class="mi">1</span> 
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">binarySearchR</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
</code></pre></div><ul>
<li>Golang</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-Golang" data-lang="Golang"><span class="kd">func</span> <span class="nf">binarySearchR</span><span class="p">(</span><span class="nx">list</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">low</span><span class="p">,</span> <span class="nx">high</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 1. figure out the base case
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">low</span> <span class="p">&gt;</span> <span class="nx">high</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>

	<span class="c1">//. 2. reduce the problem and get to the base case
</span><span class="c1"></span>	<span class="nx">mid</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">low</span> <span class="o">+</span> <span class="nx">high</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="nx">guess</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">guess</span> <span class="o">==</span> <span class="nx">item</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">mid</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">guess</span> <span class="p">&gt;</span> <span class="nx">item</span> <span class="p">{</span>
		<span class="nx">high</span> <span class="p">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">low</span> <span class="p">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">binarySearchR</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">low</span><span class="p">,</span> <span class="nx">high</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>Tip: When we got a recursive function involving an array, the base case is often an empty array or an array with one element.</p>
</blockquote>
<h2 id="3-quick-sort">3. Quick Sort</h2>
<p>3.1 Quicksort is a sorting algorithm, which is much faster than selection sort and commonly used in life.<br>
The base case for quicksort are arrays that are empty and arrays with just one element.<br>
Using D&amp;C, we can break down a array until we get the base case.</p>
<ul>
<li>Here are the steps for quick sort:</li>
</ul>
<blockquote>
<ol>
<li>Pick an element from the array as the pivot</li>
<li>Find the elements smaller than the privot and the elements larger than it(This is called Partitioning).</li>
<li>Call quicksort recursively on the two sub-arrays.</li>
<li>The sub-arrays get sorted, and then we combine the whole thing to get a sorted array.</li>
</ol>
</blockquote>
<p>3.2  Here we can see one example from the book.</p>
<p>After partitioning, we get three parts: numbers less than the pivot, the pivot and numbers greater than the pivot.</p>
<figure>
    <img src="/post/grokking_algorithm/images/quick_sort_m1.png" width="50%"/> 
</figure>

<p>Next, we&rsquo;ll quick sort the two sub-arrays.</p>
<p>Even though the two sub-arrays are not sorted, they&rsquo;re partitioned.<br>
However, sorting the whole array would be pretty easy, if they were sorted.</p>
<p>Then, we can combine the whole thing together, like this: left array + pivot + right array.<br>
We do this recursively and will get a sorted array.<br>
Here is the code, which would be easy to understand(In order to save space, We provide only the Golang code).</p>
<ul>
<li>Golang</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-Golang" data-lang="Golang"><span class="kd">func</span> <span class="nf">quickSort</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="nx">arr</span><span class="o">...</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">pivot</span> <span class="o">:=</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">less</span><span class="p">,</span> <span class="nx">greater</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{},</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">v</span> <span class="o">&lt;=</span> <span class="nx">pivot</span> <span class="p">{</span>
			<span class="nx">less</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">less</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">greater</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">greater</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;less: &#34;</span><span class="p">,</span> <span class="nx">less</span><span class="p">,</span> <span class="s">&#34;, pivot: &#34;</span><span class="p">,</span> <span class="nx">pivot</span><span class="p">,</span> <span class="s">&#34;, greater: &#34;</span><span class="p">,</span> <span class="nx">greater</span><span class="p">)</span>
	<span class="nx">lessRet</span> <span class="o">:=</span> <span class="nf">quickSort</span><span class="p">(</span><span class="nx">less</span><span class="p">)</span>
	<span class="nx">greaterRet</span> <span class="o">:=</span> <span class="nf">quickSort</span><span class="p">(</span><span class="nx">greater</span><span class="p">)</span>

	<span class="nx">ret</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="nx">lessRet</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">ret</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="nx">pivot</span><span class="p">)</span>
	<span class="nx">ret</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="nx">greaterRet</span><span class="o">...</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>If you&rsquo;d come through the explanation above, you would find this code easy to understand.<br>
Nevertheless, it&rsquo;s not efficent in memory.<br>
Here you can see codes optimized by using no extra memory space.</p>
<div class="highlight"><pre class="chroma"><code class="language-Golang" data-lang="Golang"><span class="kd">func</span> <span class="nf">quickSortE</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">l</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
	<span class="nx">pivot</span> <span class="o">:=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span> <span class="c1">// idx of element bigger than pivot
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">pivot</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nf">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
		<span class="nx">j</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="nf">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="nf">quickSortE</span><span class="p">(</span><span class="nx">arr</span><span class="p">[:</span><span class="nx">j</span><span class="p">])</span>
	<span class="nf">quickSortE</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">swap</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div><p>In order to have better performance, we use random element as the pivot:</p>
<div class="highlight"><pre class="chroma"><code class="language-Golang" data-lang="Golang"><span class="kd">func</span> <span class="nf">quickSortERand</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">l</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
	<span class="nx">rand</span><span class="p">.</span><span class="nf">Seed</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">())</span>
	<span class="nx">pIdx</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">pivot</span> <span class="o">:=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">pIdx</span><span class="p">]</span>
	<span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span> <span class="c1">// idx of element bigger than pivot
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">pivot</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nf">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
		<span class="nx">j</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="nf">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="nf">quickSortERand</span><span class="p">(</span><span class="nx">arr</span><span class="p">[:</span><span class="nx">j</span><span class="p">])</span>
	<span class="nf">quickSortERand</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><h3 id="4-big-o-notation">4. Big O notation</h3>
<p>Quicksort is unique since its speed depends on the pivot we use.<br>
Here we can see the most common Big O run times.<br>
<figure>
    <img src="/post/grokking_algorithm/images/search_time_m1.png" width="100%"/> 
</figure>
</p>
<p>Please pay attention to the example times in the chart because they are estimates of seconds per operation.<br>
Compared with Merged Sort, which is O(nlogn) and faster, quicksort is different:<br>
In the worst case, quicksorts takes O(n^2)time, which is as slow as selection sort.<br>
In the average case, quicksorts takes O(nlogn)time.</p>
<h3 id="5-merge-sort-vs-quicksort">5. Merge Sort vs. Quicksort</h3>
<p>For algorithms with O(n), there are a constant for every operation.<br>
Commonly, the constant is ignored, however, it&rsquo;ll make a difference in some cases.</p>
<ul>
<li>Quick sort has a smaller constant than merge sort.</li>
</ul>
<blockquote>
<p>Therefore, if they&rsquo;re both O(nlogn)time, quicksort will be faster.<br>
Besides, quicksort is faster in practice since it hits the average case way more often than the worst case.</p>
</blockquote>
<h3 id="6-averge-case-vs-worst-case">6. Averge case vs. Worst case</h3>
<p>The performance of quicksort is heavily affected by the pivot.<br>
Suppose we always choose the first element as the pivot, and call quick with an sorted array.<br>
Since quicksort doesn&rsquo;t to see whether the input array is already sorted, it will still try to sort it.</p>
<p>As we can see in the following figure:<br>
<figure>
    <img src="/post/grokking_algorithm/images/quick_sort_worst.png" width="70%"/> 
</figure>
</p>
<p>Since we&rsquo;re not splitting the array into two parts, one of the sub-arrays is always empty.<br>
As we always get O(n) in every level of the stack, we finally get O(n)*O(n)O(n^2)time.<br>
Therefore, the call stack is so long that it takes O(n^2) time.</p>
<p>On the other hand, if we make the middle element as the pivot, the call stack would be much shorter(O(logn).<br>
Therefore, we get operation time O(nlogn).</p>
<figure>
    <img src="/post/grokking_algorithm/images/quick_sort_avg.png" width="70%"/> 
</figure>

<ul>
<li>However, the best case is also the average case.</li>
<li>If we choose a random element in the array as the pivot, quicksort will have O(nlogn)time on average.</li>
</ul>
<pre><code>Thank you for your effort to read this part of this passage.
What are included in this passage are my study notes about algorithm.
If you want to know more details about it, I strongly recommend you this book: 
grokking algoriths: An illustrated guide for programmers and other curious people.
The author illustrate algorithms with pictures, which make people easily understand difficult questions.
</code></pre><h3 id="summary">Summary</h3>
<ul>
<li>D&amp;C works by splitting a problem into smaller parts. And the base case is usually an array with no or only one element.</li>
<li>Choosing a random element as the pivot can make quicksort complete in O(nlog n) time on average.</li>
<li>Quicksort is faster than merge sort since the constant in Big O notation matters.</li>
<li>Since O(log n) is pretty faster than O(n) with a large list, the constant never matters for simple search versus binary search.</li>
</ul>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/algorithm/">algorithm</a>
        
            <a href="/tags/quick-sort/">quick sort</a>
        
            <a href="/tags/sort/">sort</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>

    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/p/ga-2.-selection-sort/">
        
        

        <div class="article-details">
            <h2 class="article-title">GA: 2. Selection sort</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/ga-7.-dijkstras-algorithm/">
        
        

        <div class="article-details">
            <h2 class="article-title">GA: 7. Dijkstra&#39;s algorithm</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/ga-6.-breadth-first-search/">
        
        

        <div class="article-details">
            <h2 class="article-title">GA: 6. Breadth-first search</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/ga-5.-hash-tables/">
        
        

        <div class="article-details">
            <h2 class="article-title">GA: 5. Hash tables</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/ga-3.-recursion/">
        
        

        <div class="article-details">
            <h2 class="article-title">GA: 3. Recursion</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>


    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2021 Li. Mingzhi
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="2.2.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >
            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
